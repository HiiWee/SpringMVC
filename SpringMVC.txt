< ------------------------------------------------------------ Spring MVC ------------------------------------------------------------ >

* Spring을 사용하지 않고 Tomcat(Tomcat Configuration)을 이용해 웹개발 가능(Servlet, JSP)
	> 이때는 web.xml을 사용 : 사용할 라이브러리 인스턴스화(Mybatis, Tiles) 등등의 설정
	> Spring을 사용하겠다 하면 이곳에 Spring을 얹음(Spring Dispatcher) : Spring Web 개발시 Spring Dispatcher 라이브러리를 기반으로 사용

* Spring Dispatcher
	> Controller의 공통분모를 모아놓은 Front Controller를 Spring에서 제공해줌 : 그게 Spring MVC다.
	> Spring MVC를 쓰겠다면 Spring이 거의 모든것을 커버함 -> Spring을 쓰기위한 또다른 설정이 필요함 : Spring Configuration

* Spring Web : Spring Configuration이 늘어남
	> 톰캣의 web.xml 설정에서 옮겨짐 : Spring Config가 라이브러리 기타 등등을 관리하게 됨 (Mybatis, Tiles등)
	> 또한 Spring Configuration에는 일반적으로 자신만의 설정인 Servlet, Service, Security설정들이 더 추가 됨

* 결국 톰캣, 톰캣설정, 스프링, 스프링 설정 하는 방법들을 알아야함
	> Spring 버전이 변화하며 설정방법도 변화하기 시작함
		> XML, Annotation, Java등 다양한 방법 존재

* 최근에는 이러한 설정에 대한것들을 도와줄 수 있는 Spring Boot가 나옴
	> Spring MVC를 대신하기보단 설정에 대한것들을 모아서 편하게 해줄 수 있는 부가적인 프레임워크

* Spring에 Spring Boot를 얹어서 사용하게 되면 기존의 복잡한 설정을 피할수 있게 된다.
	> Stater Configuration을 필요로하는 각각의 설정들을 한번에 묶어서 라이브러리로 가지고 있다 -> 설정에 대한 라이브러리를 일일이 설정할 필요가 없다.
	> 최대한 설정을 줄이고 설정파일 하나만 둠 applicaiton.properties(단순 텍스트파일) 혹은 YAML(Json같은 형태의 표기법파일)의 설정파일 중 골라서 사용함 (주로 application.properties사용)

* Spring Boot를 사용하게 되면 결국 설정에 대한 부분이 크게 줄어든다.





< ------------------------------------------------------------ Spring MVC란 ------------------------------------------------------------ >
* Spring을 이용해서 웹 개발을 해보자

* 기존 MVC model2 방식
	> Controller : servlet, View : jsp 로 나눔 forwarding을 dispatcher를 이용해 구현함
	> 하지만 위와같이 되며 모든 Controller는 Dispatcher를 가지게 됨 --> 비효율적

* 기존 MVC model2 방식의 변화 : Dispatcher를 집중화 한 후의 모델
	> 순수하게 Controller의 기능만 구현시킴 --> 이것은 Servlet이 아니라 일반적인 자바 클래스(POJO:Plain Old Java Object)로 구현함
	> 기존 Controller로 이용하던 Servlet은 dispatcher기능만 남아있다 --> 이는 forwarding하는 기능이므로 거의 기능이 똑같음 --> 하나만 남김(디스패처의 집중화)
	> 사용자의 요청을 컨트롤러에 전달하고 요청한 결과물을 받아서 다시 view에게 전달함 (중간매개의 역할) 매우 중요한 역할

* dispatcher의 역할 
	> 사용자의 요청을 받는다는것의 의미 : 단순 요청 라우팅이아니라 사용자 입력을 쉽게 컨트롤러로 전달해줌
	> 그렇게되면 dispatcher는 servlet api를 이용해 파라미터를 받아오는 등의 서블릿의 기능을 차단해주는 역할
	> Controller에 기본적 사용할 수 있는 String, int등으로 전달해줌 혹은 객체화된 데이터로 담아서 줄 수 도있다.
	> 결국 Controller에선 Servlet 라이브러리를 하나도 사용하지 않고도 입력을 처리하게 되거나,
	  Controller가 데이터를 마련해 view로 전달하려 해도 dispatcher기능이 없으므로 디스패처가 컨트롤러에게 요청을 다시 돌려받게 되는데
	  그 때 Controller에서 어떤 view 페이지가 필요하다는 view페이지 정보만 알려주면 디스패처가 view페이지를 호출하게됨 따라서 서블릿 기능을 dispatcher로 한정한다.
	> 이게 바로 dispatcher를 따로 분리하는 이유

* 따라서 dispatcher는 서블릿, 톰캣, was라고 하는것과 Controller와 결합력을 낮추게 하며 컨트롤러를 혹시 다른 환경에서도 쓸수있게 할수있다.

* 결국 front controller(dispatcher)를 만드는것이 중요하며 만드는 것을 Spring이 제공함
	> Spring이 제공하는 front controller 라이브러리를 이용해 Controller를 만듦
	> front controller를 잘 만들게 되면 톰캣과 이별 할 수 도있게 웹개발 할 수 있다.

* Dispatcher역할을 가지고 있는 Dispatcher servlet(Spring 제공하는 기능)에 여러 URL이 옴
	> 모든 URL을 받아서 처리해야 한다.
	> 모든 URL요청이 오게됨 --> 그것을 적절히 알맞은 Controller에게 배분해야함 --> URL에 대한 정보를 어떤 Controller가 처리할지 가지고 있어야한다.
	> 따라서 Spring이 제공하는 Dispatcher 관련된 front controller 라이브러리 사용시 설정파일이 필요하다.
		> 과거엔 url매핑, 어노테이션으로 설정했으나 그 내용이 *-servlet.xml로 옮겨진다.
		> 즉 web.xml은 모든 url이 dispatcher servlet로 향하게 함,
		  이것을 알맞은 Controller에게 배분하기 위해 dispatcher servlet 설정파일에서 매핑 정보를 쓰게된다(*-servlet.xml)
	> 어떻게 보면 톰캣의 매핑정보가 스프링위로 올라간것 뿐으로 보인다. 하지만 결합력을 낮추는 부분에서 장점이 있음

여담 : 과거에는 Dispatcher Servlet을 직접 만듦 --> 요즘은 Spring것을 사용 --> Spring에 종속되는 문제 야기
	> 방법론으로 발전시켜나가는게 바람직해보임 --> 가능하면 개별적으로 만들어가며 실력을 키우는것도 좋아보입니다.

* Controller는 반환할 때 model, view의 정보를 전달함 --> dispatcher가 요청시 반환받은 두 개의 값을 가지고 view를 찾아서 관련된 데이터(Model)을 전달함
	> 즉 Spring MVC는 dispatcher servlet 라이브러리를 사용하는 것이다.





< ------------------------------------------------------------ 실습환경 준비하기 ------------------------------------------------------------ >
* spring.io에 Spring Tools 4 for Eclipse를 다운받는다.
* apache 9 다운로드 (Spring Boot는 내장 톰캣이 존재해서 따로 다운받을 필요 없음)

* 이후 다운받은 Spring Tools 4 for Eclipse를 압축풀고 내부에 contents 알집을 압축을 푼다
	> sts-4.13.0.RELEASE를 잘라내서 tools 파일로 옮김

* 이후 SpringToolSuite4.exe파일을 실행한다.




< ------------------------------------------------------------ 메이븐을 이용한 기본 웹 프로젝트 생성하기 ------------------------------------------------------------ >
* Create new Spring Starter Project == Spring Boot 이용
* 우리는 legacy Spring 이용 웹 프로젝트를 Maven 기반으로 생성해야함 --> Java EE 툴 설치

* 메이븐 프로젝트 생성
	> Group id : com.hoseok
	> Artifact id : webPrj
	> Packaging : war

* pom.xml에 web.xml이 없다는 오류가 발생하므로 apache tomcat에 ROOT/WEB-INF 폴더에서 web.xml을 가져옴
	> 추가로 오류 발생시 --> maven-war-plugin을 3버전 이상으로 임의로 플러그인 추가해줌

* JDK 버전 올리기
	> 1. pom.xml -> overview -> Properties : name=maven.compiler.source, value=1.8 추가 그리고 name=maven.compiler.target, value=1.8로 등록함 이후 update project

* JSP 파일 추가시 오류 발생
	> pom.xml에 tomcat api 추가 해줘야함 구글에 tomcat-api 검색해서 맞는 버전의 dependency 코드 긁어오기
	> 혹은 pom.xml하단에 dependencies -> add 이후 검색해서 추가하기도 가능 (Global Repository rebuild작업해야 검색가능)

* 이후 실행하고 tomcat 홈 디렉토리 등록하고 실행하면 실행된다.

* 이제 MVC 방식으로 변경해야한다




< ------------------------------------------------------------ Dispatcher Servlet 라이브러리 설정하기 ------------------------------------------------------------ >
* Spring Dispatcher를 Front 컨트롤러로 설정해야함.

* 기존에 컨트롤러와 디스패처를 같이 사용했지만 이것을 분리해 디스패처에 서블릿관련 코드를 두고 컨트롤러는 POJO 클래스로 만들기로 함

* 디스패처 서블릿은 DispatcherServlet.class를 이용한다. 이것을 다운로드 받아야함
	> 이전에 구글 tomcat api를 받아온것은 Global Repo -> Local Repo로 받아온것이다.
	> 따라서 직접 Global Repo에서 받아올 수 있다. 다만 Rebuild Index로 업데이트 이후 검색해서 사용가능(pom.xml:Dependencies -> Add -> 검색
		> 이렇게 되면 검색한것을 원격에서 가져와서 로컬로 저장함

	> 두번째로 tomcat api 검색후 Spring web MVC 검색해서 복사해서 dependency 입력


* Maven Dependencies : Local Repo에 있는 내용중 참조하고 있는 라이브러리 목록을 보여줌
	> 여기서 Spring-webmvc -> org.springframework.web.servlet -> DispatcherServlet.class를 우클릭후 Copy Qualified Name 클릭
	> 이렇게하면 패키지명과 클래스명을 한번에 받아올 수 있다.

* 위에서 복사한 내용(front controller 역할을 하는 서블릿 클래스)을 web.xml에서 설정한다.




< ------------------------------------------------------------ dispatcher-servlet.xml 파일 설정 ------------------------------------------------------------ >
* 기존에 MVC 구현하는 방식
	> View(JSP), Controller(extends HttpServlet)
	> view에 controller로 받아온 Model을 심음


* 하지만 SpringMVC에선 컨트롤러에서 서블릿을 이용하지 않을것이다.
	> Controller : POJO
	> Dispatcher : 이미 만들어져 있음(DispatcherServlet.class)

	> 따라서 지금껏 Servlet 프로그래밍을 할 땐 URL 매핑으로 Annotation을 사용했으나
	  DispatcherServlet.class는 남이 만든 서블릿을 설정하는 것이므고 소스를 가지고 있지 않으므로 XML을 이용해 설정할 수 밖에 없다.

* Dispatcher에 URL매핑을 할때는 web.xml에 하게된다. URL 매핑하기
	> Spring-webmvc -> org.springframework.web.servlet -> DispatcherServlet.class를 우클릭후 Copy Qualified Name 클릭
	> 이후 모든 URL을 Front Controller로 받기 위한 Servlet Mapping을 설정한다.
		<!-- mapping 정보를 넣음 -->
		<servlet>
		   <!-- mapping 주소가 서블릿과 연관을 맺기 위해 이름을 정해줘야 한다. -->
		   <servlet-name>dispatcher</servlet-name>
		   <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		</servlet>
	
		<!--
    	   	 front controller이므로 모든 URL을 만나면 위의 DispatcherServlet 클래스를 실행 
    	   	 이후 어떤 URL은 어떤 POJO클래스가 맞는지 분배하는 동작을 함 
   		 -->
		<servlet-mapping>
		   <servlet-name>dispatcher</servlet-name>
		   <!-- /이렇게만 작성하면 모든 URL이 통과되지만 /*로 작성하면 예외없이 모든 URL을 front controller가 받음 -->      
		   <url-pattern>/*</url-pattern>        
		</servlet-mapping>

	> 다음으로 아무 jsp파일을 실행하면 오류가 발생 
		IOException parsing XML document from ServletContext resource [/WEB-INF/dispatcher-servlet.xml]; 
		nested exception is java.io.FileNotFoundException: Could not open ServletContext resource [/WEB-INF/dispatcher-servlet.xml]

	> 우리는 현재 Dispatcher를 이용하려고 함 (모든 URL에 대해 요청을 받겠다.)
	> 현재 index.jsp를 요청했을때 어떤 URL이든 dispatcher가 받았다. 이후 dispatcher가 적절한 URL에 맞는 리소스를 배포해야 한다.
	> 하지만 그런 매핑 정보 즉 dispatcher가 어떤 페이지를 열것인지에 대한 정보는 *-servlet.xml 파일이 가지고있다.
	> 그리고 파일이 매핑정보를 가지고 있어야 오류가 나지 않음 따라서 /WEB-INF/*-servlet.xml을 생성하고 매핑을 설정해야함(원하면 설정으로 다른위치로 변경 가능)
 
	> 정리하면 모든 URL을 front controller로 받아왔으나 이후 어떤 POJO 클래스에 뿌려질건지에 대한 URL 매핑정보가 없어서 발생한다.
	> 이는 /WEB-INF/dispatcher-servlet.xml에 저장되어있고 우리가 servlet-name을 어떤걸로 정하느냐에 따라 xml파일 이름이 결정된다.(주로 dispatcher이용)


* 매핑 정보는 어떻게 넣을까?




< ------------------------------------------------------------ 스프링 컨트롤러 IndexController 작성하기 ------------------------------------------------------------ >
* Spring이 제공하는 MVC 지원 라이브러리(dispatcher lib)의 설정파일인 dispatcher-servlet.xml파일 작성하고 Index Controller 만들기
* 어떤 구문으로 만들어야 하는지 우리는 알 수 없다.
	> 이것을 제공해주는 Spring의 공식문서에서 레퍼런스 참조하기
	  https://docs.spring.io/spring-framework/docs/ 이곳에서 맞는 버전의 공식문서를 살펴봄 (core 목록 누르면 DI를 공부할 때 봤던 xml설정내용 보임)

* 기존의 Spring은 beans태그 안에서 bean태그를 이용해 설정해 어떤 클래스를 설정하면 이를 객체화해서(id=변수명, class=어떤클래스) IoC Container에 담게된다.
* 하지만 MVC에서 *-servlet.xml 설정파일은 id값이 변수명이 아니라 URL로 사용된다. 
  (컨테이너 담겨있는 객체들 중에서 사용자 요청이 URL로 옴, 그 URL을 가지고 IoC Container에서 꺼냄 무엇을? class속성에 있는 클래스로 된 객체를)

	<bean id="/index" class="com.hoseok.web.controller.IndexController">
		<!-- collaborators and configuration for this bean go here -->
	</bean>

* 이제 남은것은 Spring의 Dispatcher 클래스가 IndexController에서 컨테이너에서 꺼내고 가지고 있는 기능을 호출해야함
	> URL과 Controller를 매핑하는 정보를 id를 이용해 URL을 쓰는데 이게 bean 형태로 컨테이너에 담겨있음
	> 문제는 frontController에서 Controller를 사용하기 위해서는 요청을 수반할 수 있는 약속된 무엇 즉 기능이 있어야함
	> 약속된 함수명을 사용해야 한다. : handleRequest

* 모든 컨트롤러는 디스패처가 정의해놓은 함수를 사용해야 함, Controller interface 타입
	> POJO클래스가 이전에는 Servlet에 종속되어 있었지만 이제는 Dispatcher-Servlet에 종속되어 있다.

	public class IndexController implements Controller {

   		@Override
   		public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
   	     		// TODO Auto-generated method stub
   	    		return null;
  	  	}

	}

* 위에 Dispatch기능은 빠져있다(Spring이 제공) 따라서 함수가 반환하는 값은 Dispatch를 하기위한 ModelAndView를 반환한다.
	> ModelAndView객체를 생성해 어떤 모델을 전달하고 어떤 view에 전달할지 값을 설정하고 ModelAndview객체를 반환한다.
	public class IndexController implements Controller {

	    @Override
	    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        
        	ModelAndView mv = new ModelAndView();
        
        	// data키워드를 가진 String data를 담음 -> Model을 data란 이름으로 담아서 저장
        	mv.addObject("data", "Hello Spring MVC~");
        	// view에 대한 정보를 담음, 두가지 방법이 있다.
            	// 1. view 객체를 따로 만들어서 설정 : mv.setView(View view);
            	// 2. view의 이름만 담아서 설정 : mv.setViewName(@Nullable String viewName);
        	mv.setViewName("index.jsp");
        
        	return mv;
    	   }

	}

* model을 반환하고 나서의 실행 순서
	1. Model and View를 Dispatcher-Servlet으로 반환
	2. Dispatcher-Serlvet이 view로 Forwarding을 해 Model전달
	3. View는 출력할때 model을 사용해 사용자에게 보여줌

* 실제 IndexController를 실행하면 404오류 발생, 왜 그럴까?
	> tomcat을 이용해 tomcat Annotation을 사용할땐 매핑주소를 잘 써주지만 POJO클래스이므로(톰캣이 모름) 주소를 소스코드를 반환해버림
* 그래서 http://localhost:8080/webPrj/index로 직접 입력해 접속해도 404오류 발생 왜?
	1. IndexController를 실행하고 url에 http://localhost:8080/webPrj/index를 실행
	2. web.xml에 설정한대로 Front-Controller가 모든 URL을 받고 약속된 *-servlet.xml에서 어떤 컨트롤러를 실행할지 찾음 따라서 IndexController실행함
	3. IndexController에서 view이름을 설정하고나서 mv.setViewName("index.jsp"); 이후 포워딩하게되는 부분도 결국 하나의 요청임
	4. DispatcherServlet에선 이를 다시 받아서 *-servlet.xml로 보냄
	5. 하지만 inde.jsp로 지정된 url이 없으므로 404 오류 발생

* 여기서 기존의 web.xml설정이 위와같은 문제를 야기함
	<servlet-mapping>
	   <servlet-name>dispatcher</servlet-name>
	   <!-- /이렇게만 작성하면 모든 URL이 통과되지만 /*로 작성하면 예외없이 모든 URL을 front controller가 받음 -->      
	   <url-pattern>/*</url-pattern>
	</servlet-mapping>
	
	> url-pattern에서 /* 별표까지 쓰게 되면 어떠한 요청(forwarding이든 get요청이든)도 무조건 dispatcher를 거쳐서 지나감.
	> 결국 index.jsp를 포워딩하는 부분에서 다시 DispatcherServlet로 전달되고 *-servlet.xml 파일에서 url-mapping을 찾으므로 404오류가 발생한다.

* 결국 url-pattern에서 /* -> /로 변경
	> 이렇게 하면 DispatcherServlet을 거쳐서 dispatcher-servlet.xml에서 매핑정보를 찾지만
	> dispatcher-servlet.xml에서 리소스 정보를 찾지만 없게되면 그냥 리소스를 직접 요청함

* 이후 실행하고 URL을 요청하면 정상적으로 페이지 출력
* 하지만 *를 지우게 되면서 발생되는 문제점이 존재한다.




< ------------------------------------------------------------ View 페이지를 위한 위치 ------------------------------------------------------------ >
* url-pattern에서 /* -> /로 변경하게 되면 문제점이 발생함
	> 일단 Controller와 View가 있다. 하지만 이를 실제 Application에서 보면 하나로 생각한다.
	> 즉 사용자 요청이 왔을때 따로 요청이 오는것이 아닌 무조건 Controller를 요청하게 해야함
	> 하지만 /* -> /로 변경되면 Controller를 건너뛰고 index.jsp를 직접 요청하는일이 가능해진다.

* 따라서 애초에 View페이지를 직접접근할 수 없게끔 WEB-INF/ 경로에 숨겨놓음 이곳은 사용자가 직접 접근할 수 없는 영역임.
* 다행히도 Controller에선 접근 가능 
	> 클라이언트 접근을 막았지 서버쪽에서 파일을 요청하는것은 허락됨

* 따라서 기존에 viewName을 setting하는 작업의 URL을 변경해준다. mv.setViewName("/WEB-INF/view/index.jsp"); (경로가 길어지지만 해결할 수 있음)
* 이제 View 페이지는 Controller를 통해서만 접근이 가능하다.

* mv.setViewName("/WEB-INF/view/index.jsp");에서 절대경로가 아닌 mv.setViewName("WEB-INF/view/index.jsp"); 상대경로로해도 오류가 나지않음
* 그렇다면 만약 dispatcher-servlet.xml파일의 URL을 /aa/index로 변경하면?
	> http://localhost:8080/webPrj/aa/index 로 요청하면
	> /aa/WEB-INF/view/index.jsp을(를) 찾을 수 없습니다. 라는404 오류 발생, 왜?
	> Controller는 dispatcher-servlet.xml에 의해 http://.../aa/index라는 주소를 가짐
	> 상대경로로 입력하게되면 index라는 주소와 같은 위치에 있다고 판단해 http://.../aa/WEB-INF/view/index.jsp 이렇게 View를 찾게된다.
	> 따라서 이런것을 신경쓰고 싶지 않다면 절대경로를 이용

* 또한 dispatcher-servlet.xml파일에서 url 매핑 이름 정할때는 /를 빼먹으면 안된다. 


* 기존 url을 보면 http://localhost:8080/webPrj/index에서 프로젝트명이 URL에 들어간다.
	> 실제 서비스시 프로젝트명같은 이름은 들어가면 안된다. --> 이는 여러개의 프로젝트를 만들 수 있게 하기 위해 URL에 Context명을 붙여서 그렇다.
	> 따라서 main프로젝트 이므로 Context명을 /(root)로 변경하고 서버에서 싱크된 프로젝트를 지우고 다시 시작한다.

* http://localhost:8080/index로 접속시 index 페이지가 요청이 정상적으로 됨
	> 하지만 controller에서 실행시 index페이지가 나오지 않음(이클립스가 적당한 요청URL로 실제 위치를 요청하므로)
	> 따라서 약간의 편법으로 webapp/index라는 원래 URL구조대로 파일을 만들고 거기서 실행하면 정상적으로 index페이지가 출력된다.
	> 이렇게 되는 이유는 이클립스는 웹 루트에 있는 특정파일을 선택하고 실행하면 그 파일을 브라우저에 써준다.
	> 따라서 이것이 IndexController에 매핑했던 주소와 동일하고 우선순위가 높음
	> 결국 Controller의 URL에 dispatch가 이루어져 기존 페이지가 실행된다.




< ------------------------------------------------------------ ViewResolver 사용하기 ------------------------------------------------------------ >
* 이전에 보안을 위해 View페이지를 WEB-INF/view/로 옮김
	> 이를 통해 경로가 길어지고 페이지를 찾는 과정이 복잡해짐
* 복잡함을 해결하고 쉽게 찾을 수 있게 하는 ViewResolver를 사용해보자

* 뷰 페이지 설정은 setter를 이용했지만 오버로드 생성자를 이용해 객체 생성과 동시에 설정이 가능하다.
	> ModelAndView mv = new ModelAndView("/WEB-INF/view/index.jsp");

* /WEB-INF/view/... .jsp는 반복되며 계속 중복되므로 이것을 빼고 ModelAndView mv = new ModelAndView("index");만 남긴다.
	> 이렇게 반환하면 디스패처가 그런 리소스가 없다(JSP,경로가없음) 이것을 도와주는 것이 ViewResolver의 역할이다.
	> 반환하게 되면 이에 앞뒤에 경로와 파일확장자를 붙여 실질적인 view를 찾게 도와준다.

* dispatchar-servlet.xml 파일에서 뷰 리졸버 빈을 추가한다.
    <!-- ViewResolver 설정 -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <!-- 접두사 -->
        <property name="prefix" value="/WEB-INF/view/"/>
        <!-- 접미사 -->
        <property name="suffix" value=".jsp"/>
    </bean>




< ------------------------------------------------------------ HTML파일 설정하기 ------------------------------------------------------------ >
* 파일 다운로드 및 웹 루트로 옮김
* css미적용 및 이미지 로드 안됨 --> 왜?




< ------------------------------------------------------------ 정적파일 서비스하기 ------------------------------------------------------------ >
* images/logo.png파일이 존재 다만 실제로 경로를 열면 404에러 발생(localhost:8080/images/logo.png)
* 이유는 기본적으로 Spring은 정적인 파일을 제공하지 않도록 막아놓아서 발생함
* HTML, img등은 서비스 불가능하도록 막아놨지만 jsp는 열어놓음

* 위와같은 일이 발생하는 이유
	> web.xml에서 url-pattern이 /이다.
	> /* : jsp까지 막겠다는 의미
	> /  : 기본적인 정적인 파일은 막지만 jsp는 허용함
	> 따라서 정적(static)인파일(img, js, css 등)이 로드되는것을 막는다.

* 이를 위해 따로 리소스 설정을 해주어야 한다.
	<mvc:resources location="/resource/" mapping="/resource/**"
	> 위와같이 resource라는 폴더안에 static file들을 모아놓고 url을 리소스를 통해 제공할 수 있게 만듦

* 이것을 위해 schema, namespace 설정이 필요하다.
	> dispatcher-servlet.xml에서 리소스 설정이 mvc: 접두사를 이용해 설정한다.
	> 기본적으로 dispatcher-servlet.xml를 처리하는 처리기는 beans라 하는것을 처리한다.
	> 우리는 mvc를 담당하고 있는 다른 처리기가 필요하다.

* mvc처리기 이용하기
	> beans 태그에 설정을 추가한다.
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="...다른설정..."
		xmlns:mvc="http://www.springframework.org/schema/mvc"		<< 추가
		xsi:schemaLocation="...다른설정...
       		http://www.springframework.org/schema/mvc
        	https://www.springframework.org/schema/mvc/spring-mvc.xsd">	<< 추가

	> 이후 사용가능한 태그 목록을 보면 mvc접두사가 붙은 태그들도 이용할 수 있게된다.

* 설정들의 의미
	> 우리는 태그로 xml에서 어떤 명령어를 입력한다.

	> xsi:schemaLocation="http://www.springframework.org/schema/mvc
     			https://www.springframework.org/schema/mvc/spring-mvc.xsd" 페이지 내에서 쓸 수 있는 태그를 정의하는 파일 (스키마파일)
		> 그리고 그 안에 들어가는 url들이 스키마 파일 정의에 대한 이름들이 된다.
		> 이름이 긴 이유? : 다른 스키마 파일들도 같이 포함시키려면 중복되면 안된다. (클래스 만들때 패키지명 같이 사용하는것처럼) 따라서 도메인명 사용

	> xmlns:mvc="http://www.springframework.org/schema/mvc"
			스키마 파일의 원래 이름을 가지고 쓰긴 너무 길어서 이름을 대신해서 mvc라는 접두사를 이용한다.
			즉 xmlns:mvc="이곳엔 스키마를 입력한다." 그리고 mvc는 스키마를 식별하는 namespace가 된다.

	> 즉 mvc:를 붙여서 태그를 이용하면 스키마에 정의되어 있는 것을 사용하는 것이다.
	
* 우리는 여기서 mvc:resources 태그를 사용할 것이다.
	> <mvc:resources location="" mapping="" />
	> Spring dispatcher가 위 명령어를 읽으면 mvc설정을 따라서 맞게 행동함
	> mapping : 특별한 url을 사용자가 요청
	> location : 사용자가 요청한 url(mapping)은 여기에서 찾게됨(하위폴더 포함)

	> <mvc:resources location="/resource/" mapping="/resource/**" />

* 하지만 mapping을 /resource/**로 두었으므로 이미지를 불러오기 위해선 /images/...png 파일들의 경로를 /resource/images/...png로 변경해야함 >> 번거로움

	> <mvc:resources location="/static/" mapping="/**" />
	> 이미지가 루트에 있는것처럼 둔다.
	> 기존 html/ 폴더에 static 파일을 두고 webapp/에 static/이라는 이름으로 옮긴다.
	> 따라서 정적인 파일이 요청이 되면 모든 요청은 /static/이라는 폴더에서 뒤진다.
	> 실제로는 static이란 폴더안에 이미지 파일이 있지만 mapping을 /**로 두었으므로 static이 root가 되는것처럼 작용한다.

* 실제 경로 테스트 해보기
	> http://localhost:8080/static/images/banner3.svg	>> 404 오류 발생 (mapping을 /로 두었으므로)
	> http://localhost:8080/images/banner3.svg		>> 정상적으로 이미지 출력됨

	> 결국 /static/과 /** 매핑되었으므로 static/을 root로 생각한다. 따라서 모든 static 파일들은 static/파일아래에 둔다.




< ------------------------------------------------------------ 공지사항 컨트롤러 추가하기 ------------------------------------------------------------ >
* static/ 폴더의 구조를 그대로 view안에 notice/detail.jsp, notice/list.jsp 파일 생성 및 기존 html파일에서 내용 복사해서 가져오기
* 이에 맞는 컨트롤러도 생성 com.hoseok.web.controller.notice.ListController.java, DetailController.java

* Controller에서는 View, Model을 준비해서 DispatcherServlet 클래스로 넘겨주는데 일단 IndexController.java의 내용을 빌려쓴다.
	> 올바른 경로 작성하기 ViewResolver에서 접두사:/WEB-INF/view/, 접미사:.jsp이므로 제외하고 작성 ex) "notice/list"

* 이제 URL 매핑을 시켜줘야함 --> dispatcher-servlet.xml
	<bean id="/notice/list" class="com.hoseok.web.controller.notice.ListController"/>
	<bean id="/notice/detail" class="com.hoseok.web.controller.notice.DetailController"/>

* 이제 기존 xxx.html로 링크되어있던 하이퍼링크들을 컨트롤러에 매핑한 URL로 변경해준다.




< ------------------------------------------------------------ Detail 컨트롤러 추가와 View페이지 집중화의 필요성 ------------------------------------------------------------ >
* DetailController를 ListController와 동일하게 만들어주고 URL만 변경해준다.
* 다만 이후 dispatcher-servlet.xml에서 매핑을 해준다.

* 이렇게 만들고 notice/detail까지 들어가게 되면 이곳에서 header의 url들이 모두 list.html로 매핑되어있는것을 알 수 있다.
	> 그렇다면 header의 어떤 내용을 수정하기 위해서 모든 페이지를 일일이 변경해야할까? --> 비 효율적
	> 따라서 View 페이지의 집중화가 필요해짐




< ------------------------------------------------------------ 페이지 공통분모 집중화 ------------------------------------------------------------ >
* 지난시간 detail, list, index페이지에서 공통으로 나타나는 페이지의 일부분을 볼 수 있다.
	> 페이지를 어떻게 나누고 집중화 할 수 있을지 알아보자
	> 기존 페이지들은 공통 부분을 수정하게 되면 모든 페이지를 다 수정해야만 한다.
	> page구조에서 어떤 Content를 가지는 내용은 링크를타고 맨 끝에 있는 페이지에 일반적으로 존재함
	> 또한 끝 페이지는 목록, 자세한페이지, 수정 등 페이지가 왔다갔다 한다.
		> 페이지를 라우팅하기 위한 링크들은 페이지 내부에 존재 따라서 목록에서 클릭-> 자세한페이지 수정클릭-> 수정페이지
	> 그리고 이와 유사한 컨텐츠들은 좌측 메뉴에 묶여서 존재하고 클릭시 유사한 페이지들이 왔다갔다함
	> 층을 올라갈수록 하위페이지들을 찾아가기위한 링크들이 존재하고 위로 올라가는 내용들은 하위페이지의 요약본, 노출할것, 분석된 데이터들을 보여줌
	> 결국 최상위의 페이지는 전체 사이트에 대한 링크들을 가짐

* 다만 모든 페이지마다 공통으로 가지는 영역들이 존재함 (header, footer), 일정영역에서 동일한 aside 등이 있다.

* 따라서 공통 부분을 분리하여 기존 페이지들이 공통으로 참조하도록 한다.
	> JSP는 공통분모를 분리해서 다른폴더에 두고 어떤 페이지에서 쓰겠다 하면 jsp:include를 이용해 외부페이지를 링크해 쓸 수 있는 방법제공 하지만 사용하진 않을것

* jsp:include의 문제점 
	> 한 페이지가 다른곳에서 3개의 jsp:include를 참고하게 된다.
	> 하지만 각각의 jsp:include들은 여러페이지에서 사용되므로 페이지마다 include하는것들이 중복되어 나타난다.
	> 따라서 페이지를 만들때마다 include를 해줘야하는 부분이 불편해짐 --> 이것도 집중화 할 수 있는 방법이 있을까?

* Tiles 라이브러리
	> include하는 내용마저도 layout 이라는 이름으로 따로 만들고 페이지 추가시 main 부분에 해당되는것만 만들게 된다.

* 실제로 만든 페이지의 header, footer, aside, 그리고 content에 해당되는 main과 layout을 나눠보자





< ------------------------------------------------------------ 페이지 모듈 분리하기 ------------------------------------------------------------ >
* 페이지 집중화를 위해 페이지에서 공통으로 나타나는 부분과 그렇지 않은부분을 나눠보자

* index.jsp의 공통부분 분리하기
	> view/inc/header.jsp, footer.jsp 생성하고 index.jsp에서 header와 footer부분을 각각의 jsp파일로 옮긴다.

* list.jsp의 header, footer부분은 동일하므로 지우기

* list.jsp, detail.jsp의 공통부분이 존재 aside, visual영역이 공통분모 이므로 빼서 공통적으로 관리한다(customer/inc/)
	> view/inc/안에는 view 전체에서 사용되는 부분이고
	> list와 detail의 공통부분은 공지사항, 자주하는질문, 수강문의, 이벤트들에서 같이 사용되는 메뉴이므로 다른폴더에 생성하는것이 바람직함
	> 고객센터 관련 내용이므로 customer/inc/폴더에 생성한다.

* 그리고 notice/ 폴더도 고객이 사용하는 메뉴이므로 customer/ 에 묶인다. 
  따라서 옮겨서 같이 담는것이 페이지 관리가 바람직해짐 이곳에 공지사항, 자주하는질문, 수강문의, 이벤트등의 폴더들도 생성해서 같이 관리함

* 결국 list, detail.jsp는 main과 main을 포함하는 껍데기들만 남아있다.
	> 껍데기들은 aside, visual, header, footer를 배치할 수 있는 영역 --> layout
	> 그리고 나머지는 main 페이지
	> 결국 list, detail.jsp는 총 2개의 페이지가 남아있다. : main, layout

* 마지막으로 main도 분리하고 남아있는 정보(layout)도 하나의 페이지가 될 것이다.
	> view/customer/inc에 list.jsp를 복사하고 layout.jsp로 이름을 변경하고 레이아웃의 역할만 남긴다.(main부분을 잘라냄)
	> 그리고 기존의 list.jsp의 내용을 지우고 잘라낸 main 내용만 붙인다.
* 이렇게 list.jsp는 main내용만 남아있고 나머지 공통적인 부분들이 정리되고 모듈화가 됨

* 이걸 합치기 위해서 Tiles 라이브러리를 설정해야 한다.





< ------------------------------------------------------------ Tiles 지시서 작성하기 ------------------------------------------------------------ >
* 페이지에서 나타내는 공통부분을 쪼개서 inc/ 폴더에 담아둠
* Tiles를 이용하기 위한 지시서를 작성하는 법에대해 알아보자!

* MVC Model2
	> /notice/list (사용자 요청 오면) -> Controller는 View를 찾기위해 notice/list 문자열 반환 -> ViewResolver가 prefix, suffix문자열 붙임
	  -> 접두,접미사를 붙인 형태의 리소스를 찾아서 결과를 사용자에게 반환함

* 이 때 Controller가 반환하는 형태 하나 더 생김 -> notice.list
	> "WEB-INF/view/notice/list.jsp"는 실제로 페이지를 찾기위한 파일명을 반환한것
	> 또 다른 형태인 notice.list형태로 값을 반환하면 이를 가지고 Tiles를 호출함

* Tiles가 notice.list형태를 받으면 형태에 맞는 page조각들을 조합해서 반환하게 됨
	> 어떤 페이지들이 어떻게 결합되어야 하는지는 Tiles에게 지시해야함
	> 그렇게 되면 Tiles가 지시대로 페이지를 결합시켜서 돌려주게 된다.

* Controller가 notice.list, notice/list 둘 중에 하나를 반환한다 그걸 어떻게 알까?
	> 우선순위가 존재하므로 notice.list의 우선순위를 높임
	> 초기에는 notice.list형태로 반환해서 먼저 Tiles지시서를 뒤져보고 없으면 notice/list를 찾음 (그래도 없게되면 오류발생)

* notice.list에 대한 지시서를 작성할 때 두 가지의 지시사항이 필요
	1. 특정 이름으로 반환을 받으면 그것을 어떤 조합으로 붙일지 지시 필요
	2. 페이지를 붙일경우에 layout에서 어떤 위치에 붙일지 위치를 정하는 지시 필요(layout에서 페이지를 어떤식으로 붙일것인지)

* https://tiles.apache.org/에 접속해 라이브러리를 다운받음
	> https://tiles.apache.org/framework/tutorial/basic/pages.html 에서 xml 형식을 가져옴 주로 /WEB-INF/tiles.xml로 저장함
[tiles.xml]
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tiles-definitions PUBLIC
       "-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN"
       "http://tiles.apache.org/dtds/tiles-config_3_0.dtd">
<tiles-definitions>
	<definition name="notice.list" template="/layouts/classic.jsp">
		<put-attribute name="title" value="Tiles tutorial homepage" />
		<put-attribute name="header" value="/tiles/banner.jsp" />
		<put-attribute name="menu" value="/tiles/common_menu.jsp" />
		<put-attribute name="body" value="/tiles/home_body.jsp" />
		<put-attribute name="footer" value="/tiles/credits.jsp" />
	</definition>
</tiles-definitions>

* 위의 설정에서 definition태그의 name속성은 Controller가 반환하게 될 이름이다.
* 따라서 Controller에서는 View, Model을 준비해서 DispatcherServlet 클래스로 넘겨주는데 이때의 값을 notice/list 에서 notice.list로 변경한다.
	> 꼭 .이 아니라 다른 방식을 사용해도 되지만 . 문자가 패턴만들기가 간편하다

* 그렇다면 detail.jsp페이지도 또 definition을 추가해야하나?
	> 하나로 합칠 수 있는 방법이 있다.

* tiles.xml에서 notice.list라는 이름을 받게 되면 나눠졌던 페이지들을 합치기 위한 페이지를 담게된다.
	> template속성에 어떤 layout을 사용할지 설정한다. (web root를 기반으로 설정)
	> layout에 붙이기 위해 조각난 페이지들을 put-attribute태그에 붙이게 된다.

* put-attribute 태그 속성
	> name : 사용자가 정하는 이름(layout의 어떤 부분인지)
	> value : 실제 View파일의 경로(web root를 기반으로 설정)

* 최종 xml (각 controller의 DispatcherServlet Class에 전달하는 값은 definition태그의 name속성과 동일해야 한다.)
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE tiles-definitions PUBLIC
           "-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN"
           "http://tiles.apache.org/dtds/tiles-config_3_0.dtd">
    <tiles-definitions>
        <definition name="notice.list" template="/WEB-INF/view/customer/inc/layout.jsp">
            <put-attribute name="title" value="Tiles tutorial homepage" />
            <put-attribute name="header" value="/WEB-INF/view/inc/header.jsp" />
            <put-attribute name="visual" value="/WEB-INF/view/customer/inc/visual.jsp" />
            <put-attribute name="aside" value="/WEB-INF/view/customer/inc/aside.jsp" />
            <put-attribute name="body" value="/WEB-INF/view/customer/notice/list.jsp" />
            <put-attribute name="footer" value="/WEB-INF/view/inc/footer.jsp" />
        </definition>
        <definition name="notice.detail" template="/WEB-INF/view/customer/inc/layout.jsp">
            <put-attribute name="title" value="Tiles tutorial homepage" />
            <put-attribute name="header" value="/WEB-INF/view/inc/header.jsp" />
            <put-attribute name="visual" value="/WEB-INF/view/customer/inc/visual.jsp" />
            <put-attribute name="aside" value="/WEB-INF/view/customer/inc/aside.jsp" />
            <put-attribute name="body" value="/WEB-INF/view/customer/notice/detail.jsp" />
            <put-attribute name="footer" value="/WEB-INF/view/inc/footer.jsp" />
        </definition>
    </tiles-definitions>


* 지시서는 완성되었지만 layout에서 각각의 조각들을 어떻게 어느위치에 붙일것인지 설정해야함





< ------------------------------------------------------------ layout 페이지 만들기 및 Tiles 라이브러리 설정 ------------------------------------------------------------ >
* Tiles가 사용하게 될 지시서는 작성
	> notice.list와 같이 Tiles가 지시받는 목록중에 있는 이름을 받음 이 때 두가지의 지시서 필요
		1. notice.list를 가지고 만들어낼 조각들의 명단 필요 --> tiles.xml(어떤 페이지들이 필요한가에 대한 목록)
		2. page들을 layout의 어디에다 포함시킬지 지시서 필요

* Tiles 제공 태그 라이브러리
	> Maven project이므로 pom.xml로 받아옴(Global Repo로 검색)
	> tiles.jsp 추가

* layout.jsp에 태그라이브러리 추가
	<%@ taglib prefix="tiles" uri="http://tiles.apache.org/tags-tiles" %>

* layout에 각 위치에 맞는 조각들(page) 세팅
	> <tiles:insertAttribute name="header" /> 태그 이용
	> name은 tiles.xml에서 put-attribute(속성을) layout에 그 속성을 insert하겠다는 의미

* tiles.xml put-attribute의 name중 title을 페이지가 아니라 문자열이다.
	> <tiles:getAsString name="title"/> 형식으로 문자열을 꽂을 수 있다.

* 한 가지의 설정을 더 해야 실행할 수 있다.





< ------------------------------------------------------------ Tiles ViewResolver 설정하기 ------------------------------------------------------------ >
* Tiles를 이용하기 위해 페이지 명단과 어디에 포함시킬지에 대한 지시서 완성 하지만, 한 가지 설정이 더 남음

* 사용자가 URL 요청 -> Controller가 URL(/notice/list)을 받음 -> 데이터베이스를 이용해 데이터생성(미구현) -> 그것을 출력하기 위한 페이지 요청
  -> 이때 jsp페이지가 아닌 tiles를 이용

	> jsp를 요청할 때는 Controller가 반환하는 문자열을 이용해 페이지를 찾아주는 작업을 함 --> 이 때 리소스를 찾기위해 접두사, 접미사를 붙임

* 이번에는 notice.list를 반환하게 되면 이것으로 페이지를 합치는 작업을 함 이 때 tiles를 요청하고 페이지를 만들어내는 과정이 있다.
  notice.list에 해당되는 페이지를 찾아주는 역할을 하는 것이 있어야함
	> 지금까지는 페이지명단과 어디에 포함시킬지에 대한 내용은 완성했지만, notice.list를 가지고 page를 이어주는 tiles ViewResolver가 있어야함
	> 즉 반환되는것을(notice.list) tiles.xml 페이지 명단을 찾아서 연결해야함 --> 지시서가 어디있는지 알아야함

* 즉 기존의 InternalResourceViewResolver 말고 다른 View Resolver가 필요하다
    <!-- Tiles ViewResolver 설정 -->
    <bean class="org.springframework.web.servlet.view.UrlBasedViewResolver">
        <property name="viewClass" value="org.springframework.web.servlet.view.tiles3.TilesView" />
        <property name="order" value="1" />
    </bean>
    
    <bean class="org.springframework.web.servlet.view.tiles3.TilesConfigurer">
        <property name="definitions" value="/WEB-INF/tiles.xml"/>
    </bean>

	> TilesConfigurer가 아파치 타일즈로 타일 정의를 불러오고 배치함
	> UrlBasedViewResolver는 view를 설정하는데 내부적으로 serViewClass로 TilesView를 세팅하고 setOrder로 첫번째로 tiles.xml을 뒤져본다
	  tiles.xml에 반환된 값(ex:notice.list)과 일치하는것이 존재하면 페이지 조각을 조립하고 화면에 출력한다.
	  만약 존재하지 않으면(notice/list) 후에 InternalResourceViewResolver에서 직접적으로 View페이지를 찾게된다. (prefix, suffix붙여서)

* 따라서 기존에 만들었던 InternalResourceViewResolver도 order를 2로 setting 해줘야 함
    <!-- ViewResolver 설정 -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <!-- 접두사 -->
        <property name="prefix" value="/WEB-INF/view/" />
        <!-- 접미사 -->
        <property name="suffix" value=".jsp" />
        <property name="order" value="2" />
    </bean>

* 일단 실행하게 되면 jstl 라이브러리가 없으므로 오류가 발생 따라서 pom.xml에서 javax.servlet jstl 라이브러리를 추가해야함

* 아직 index.jsp는 적용하지 않았으므로 직접 notice/list url을 요청하면 view 페이지들이 정상적으로 합쳐진걸 볼 수 있다.





< ------------------------------------------------------------ Tiles 설정에 Wildcard 이용하기 ------------------------------------------------------------ >
* Tiles 설정에서 페이지들을 추가할 때 마다 definition을 계속 만들어야 하는 비효율적인 작업을 보임

* notice.list와 notice.detail은 페이지 이름만 다를뿐 나머지 조합하는 페이지는 동일
* Tiles 라이브러리는 이러한것을 도와주기 위한 패턴 문자인 Wildcard를 제공해준다.

* definition태그에서 notice.list혹은 notice.detail로 페이지의 부분이 달라진다 따라서 notice.*과 같이 변동되는 부분을 *로 둔다 이는 2개 이상 사용 될 수 있다.
	> ex) notice.*.*
* definition 태그 내부에서 *의 개수에 따라 번호가 순차적으로 부과 된다. 따라서 {1}, {2}와 같이 사용 가능하다
* 또한 Wildcard로 정규식도 사용 가능하다
* 위와 같은 Wildcard의 사용법은 https://tiles.apache.org/framework/tutorial/advanced/wildcard.html에 가보면 자세히 볼 수 있다.

<tiles-definitions>
    <definition name="notice.*" template="/WEB-INF/view/customer/inc/layout.jsp">
        <put-attribute name="title" value="공지사항목록" />
        <put-attribute name="header" value="/WEB-INF/view/inc/header.jsp" />
        <put-attribute name="visual" value="/WEB-INF/view/customer/inc/visual.jsp" />
        <put-attribute name="aside" value="/WEB-INF/view/customer/inc/aside.jsp" />
        <put-attribute name="body" value="/WEB-INF/view/customer/notice/{1}.jsp" />		>> 상단의 *의 값을 이용하기 위한 표현식 1개밖에 없으므로 {1}로 표기
        <put-attribute name="footer" value="/WEB-INF/view/inc/footer.jsp" />
    </definition>
</tiles-definitions>

* 위와같이 Wildcard를 사용 가능하다.





< ------------------------------------------------------------ Root 페이지들을 위한 Layout 페이지 만들기 ------------------------------------------------------------ >
* Index page에서 header와 footer가 없음 --> root 페이지들은 Tiles 설정을 어떻게 할까?
* index를 위한 layout을 만들어야함
* root에 있는 페이지들만 사용하는 layout 필요  /WEB-INF/view/inc/layout.jsp 생성하고 기존의 index.jsp에서 body 영역을 지운 파일을 이용한다.
* 어떻게 조합할지 구성하고 tiles.xml도 추가해준다.
	> 이때 name을 *을 주게되면 "모든파일"이 해당되므로 뒤에있는 notice.*에 기회가 가지 않음 --> 주의 해야함
* 그렇다면 두번째로 내려야 하나?
	> 자칫하면 *을 찾는 과정에서 무한루프에 빠질 수 있다.
* 결국 root라는 폴더에 담고 root.*을 이용하는것이 바람직함
	> 다만 실제 폴더를 생성하는것이 아닌 형식적인 의미로 사용
	> IndexController에서 반환하는 값을 root.index로 변경해야함

* 실행하면 정상적으로 동작

* Tiles 라이브러리 기능 및 설정 방법을 알아봄

* Spring MVC에서 제공하는 기능을 알아보자
	> 주로 FrontController기능을 제공해준다. FrontController는 출력과 입력을 담당함
	> 지금까지 입력을 다루지 않았다 따라서 어떻게 다룰 수 있는지 알아보자





< ------------------------------------------------------------ 데이터 서비스 클래스 준비하기(NoticeService) ------------------------------------------------------------ >
* View에 심을 데이터와 사용자의 입력을 받아야함
	> DB는 나중에 임시로 사용될만한 데이터 서비스 객체 필요 (JDBCPrj에서 com.hoseok.app.service.NoticeSevice.java이용)
	> 서비스를 이용하기 위한 entity 객체인 Notice.java도 가져옴
	> 패키지명 변경하고 일단 임시로 사용할 객체들

* MySQL 이용





< ------------------------------------------------------------ 서비스 객체 사용하기 ------------------------------------------------------------ >
* NoticeService와 Entity인 Notice를 가져옴 --> 두 가지를 이용해 query 결과를 view에서 볼 수 있도록 해보자
* JDBC driver를 pom.xml에 추가

* NoticeService를 이용해 Model을 만들어 View에 보내 출력해야함
	> Controller에서 직접 NoticeService를 객체화? --> 비효율적 --> Spring에 DI를 이용하자
	> *-servlet.xml에 bean으로 이용해 DI하면 IoC Container에 담기게 됨
* Spring이 실행시 bean태그를 읽으면 IoC Container에 담아놓는다.
* 따라서 IoC 컨테이너에 담긴 객체들을 가져다 쓰거나 Spring이란 녀석이 DispatcherServlet에서 가져다 쓰기도 함

* 여기에(HandlerMapping) NoticeService를 생성한다. 그리고 Controller에 DI한다.
	> 이렇게 만들어 놓으면 여러 Controller가 사용할 수 있다.
	[NoticeService 객체]
    <!-- NoticeService bean 생성(객체화 되어 IoC Container에 담겨지게 된다.) -->
    <bean id="noticeService" class="com.hoseok.web.service.NoticeService" />


	[ListController에 DI]
    <!-- ListController에 DI(setNoticeService) -->
    <bean name="/notice/list" class="com.hoseok.web.controller.notice.ListController">
        <property name="noticeService" ref="noticeService"></property>
    </bean>
    <bean name="/notice/detail" class="com.hoseok.web.controller.notice.DetailController" />


* 위와같이 DI하기 위해서는 ListController에 필드와 메소드가 필요하다.
	> setNoticeService() 메소드와 setting한 값을 담기위한 NoticeService noticeService 필드가 필요하다.

    private NoticeService noticeService;

    public void setNoticeService(NoticeService noticeService) {
        this.noticeService = noticeService;
    }


* 참고로 prperty에서 name은 setter를 의미한다. 그리고 ref은 위에서 생성한 noticeService이름을 가진 NoticeService객체를 참조하여 DI한다.


* 이렇게 되면 bean을 이용해 데이터를 활용할 수 있다.
	> List<Notice> list = noticeService.getList(1, "TITLE", "");
	> mv.addObject("list", list);

* 이렇게 bean을 이용해 list를 받아오고 받아온 list를 "list"이름으로 Model로 지정하여 DispatcherServlet으로 보낸다.
	> View가 list라는 이름을 통해서 데이터를 출력할 수 있다.

* View도 jstl태그중 forEach를 이용해 반복하면서 Notice의 값들을 출력한다. 이때 NOTICE_VIEW 뷰를 이용한다.
	> <c:forEach var="notice" items="${list}"></c:forEach>
	> Model이름을 list로 저장했으므로 list에 담겨있는 각 Notice객체 항목은 notice를 이용해 출력한다.(EL태그)
	> ${notice.title} --> Notice.getTitle()메소드 호출

	> forEach와 EL태그를 사용하지 않고 ${notice.title}을 자바코드로 나타내면
                <%
                List<Notice> list = (List<Notice>) request.getAttribute("list");
                Notice notice = list.get(0);
                System.out.println(notice.getTitle());
                %>
	> 위와같은 코드를 EL 및 JSTL을 이용하면 간단하게 표현 가능






< ------------------------------------------------------------ 서비스 객체 분리하기 ------------------------------------------------------------ >
* Service 객체를이용해 데이터베이스를 간단히 연결함
* Spring을 이용할 때는 Enterprise형태의 어플리케이션을 만드는것
	> Service 클래스를 직접 Controller가 사용하지 않음
* 따라서 결합력을 낮추기 위해서 Service 객체를 분리해야 한다.

* Service 객체를 다른 객체로 바꾸기
	> 지금까진 Controller는 멤버변수로 Service변수를 만들어 Service 클래스의 이름을 자료형으로 사용했다.
	> 즉 NoticeService자료형을 이용해 변수를 사용함

* Service를 자료형으로 사용하게되는것의 문제
	> 만약 JDBC를 이용하다가 JPA, Mybatis등 구현기술이 달라져서 JDBC를 사용하지 못하게되면
		(서비스를 해야할 기능이 아닌 구현하기 위한 구현기술이 달라짐)
	> JDBC를 이용하다 변경해야함 --> 변경하게되면 --> Controller에서 Service자료형을 이용하고 있었으므로 에러 발생
	> 즉 서비스 클래스 이름을 가지고 직접 사용하게 되면 결합력이 굉장히 높아짐
	> 사실 서비스 할 수 있는 내용만 관심있고 구현기술은 관심이 없다 --> 어차피 메소드 이용

* Service객체를 직접 사용하지 않고 기능에만 포커스가 되어있는 Interface를 자료형으로 대신해 사용하면 위와같은 변경이 있어도 오류가 발생하지 않는다.
	> Interface를 구현하고 있는 클래스가 있으면 꽂아넣을때 인터페이스만 맞으면 어떤 객체가 구현한것이든 상관이 없다 -> 기능만 맞으면 되니까
	> 결국 인터페이스를 구현한 개체가 어떤 것으로 구현했는지(JDBC, JPA, Mybatis)는 관심가지지 않아도 됨

* 인터페이스를 구현한 객체들을 서비스에 꽂는 작업은 코드로 구현해야함
	> 이런 것들을 외부설정 *-servlet.xml로 DI작업을 해주면 자바 코드를 수정할필요가 없다.
	> 결국 구현하기 위한 구현기술을 쉽게 변경할 수 있게된다.

* 실제로 코드에 서비스 인터페이스를 추가하여 반영하자
	> 이후 세팅하는 작업은 인터페이스 구현 객체가 아닌 인터페이스 이름을 기반으로 세팅

* 기존 service 패키지는 인터페이스를 담고 기존의 구현체들은 별도의 특화된 패키지로 변경
	> com.hoseok.web.service.NoticeService.java -> com.hoseok.web.service.jdbc.JDBCNoticeService.java
	> 원래는 DB구현체는 Service에서 직접 구현하지 않고 계층이 더 나뉘어서 DAO객체에서 구현하게 된다.(일단 지금은 Service에서 이용)

* 그리고 기존 service패키지에 인터페이스를 생성한다. NoticeService
	> 이렇게 하여 구현체에 대한 구체적 이름을 가지면 : 구현체를 사용한 클래스
	> 기존 NoticeService는 인터페이스로서 약속을 정함

* ListController에서 NoticeService인터페이스 타입으로 자료형을 지정한다.
	> 따라서 JDBC를 구현한 클래스로부터 멀어지게됐다(약한 결합력)

* JDBCNoticeService의 메소드들을 NoticeService로 옮기고 구체적인 구현부분은 지운다(예외처리에 해당되는 것들은 놔둠)
* 이렇게 하면 NoticeService 인터페이스가 완성된다. 그리고 정의된 내용을 JDBCNoticeService가 구현했다.
	> 결국 ListController에선 NoticeService즉 인터페이스 타입을 이용했으므로 구현 클래스가 변경되던 말던 상관이 없다.

* 마지막 문제로 인터페이스를 컨트롤러에 두고 객체를 정의하고 DI해줘야함
	> 하지만 이전에 구현한 DI를 보면
	[NoticeService 객체]
    <!-- NoticeService bean 생성(객체화 되어 IoC Container에 담겨지게 된다.) -->
    <bean id="noticeService" class="com.hoseok.web.service.JDBCNoticeService" />


	[ListController에 DI]
    <!-- ListController에 DI(setNoticeService) -->
    <bean name="/notice/list" class="com.hoseok.web.controller.notice.ListController">
        <property name="noticeService" ref="noticeService"></property>
    </bean>
    <bean name="/notice/detail" class="com.hoseok.web.controller.notice.DetailController" />

	> NoticeService 구현 객체에서 패키지 및 클래스를 JDBCNoticeService로 변경만 해주면 된다.
	> setNoticeService의 인자의 자료형과 필드의 자료형이 이미 인터페이스형식으로 변경했기 때문에 가능하다.

* 나중에 JPA를 사용하게 되면 bean의 클래스를 JPA를 구현한 서비스인 JPANoticeService로 변경만 해주면 된다
	> 즉 소스코드의 변경없이 변화가 가능해진다.

* 정상적으로 실행됨을 알 수 있다.





< ------------------------------------------------------------ Connection 정보 분리하기 ------------------------------------------------------------ >
* DB 연결정보 분리하기
	> 자바코드에 ID, Pwd, url, driver 두게 되면 서비스를 배포하게되면 컴파일된 바이너리 코드를 배포함
	> 패스워드를 주기적으로 바꾸어야 할 때 소스코드 없이 배포된 상태에서 변경할 수 없음
	> 패스워드 변경을 위해 소스코드 변경 및 컴파일 후 재배포를 해야함
	> 각 DAO의 비밀번호를 변경하고 재배포하는것이 문제가 된다.
	> 혹은 DB가 로컬호스트가 아니라 위치가 변경되어도 재배포를 해야함 --> 합당하지 않음

* 따라서 변경에 대한 부분들을 빼서 xml로 둠
	> 이후 xml에서 객체화 한 것을 DI해서 이용하게 되면 변경에 대한 부분도 xml텍스트만 수정하면 된다.
	> text파일은 배포되어도 text그대로 배포되므로 수정이 용이함


* 단순히 문자열 4개를 만들어 문자열을 DI해도 됨 하지만 4개의 정보를 하나의 그릇(객체)에 담아쓰는것이 바람직해보임
* 4개를 묶고 있는 Data정보를 담을 수 있는 인터페이스 존재 : javax.sq.DataSource
	> 이를 필드로 두고 xml에서 바인딩 할 수 있는 객체를 준비하고 세팅하기위해 setter도 정의한다.

* 기존의 4개의 문자열을 이용해 드라이브를 로드, 커넥션 생성 하던 부분을 주석처리하고 DataSource를 이용한다.
	> 변경 전 : Connection con = DriverManager.getConnection(url, uid, pwd);
	> 변경 후 : Connection con = dataSource.getConnection(); (dataSource를 xml을 통해 DI받았다고 가정할 떄 가능)

* 이제 dataSource에 어떤 객체를 꽂을지 작업해야함
	> 어떤 객체를 만들고 어떻게 꽂아넣을것인가 --> xml에서 설정

* xml설정하기
    <bean id="noticeService" class="com.hoseok.web.service.jdbc.JDBCNoticeService">
        <!-- DB연결정보 객체 DI -->
        <property name="dataSource" ref="dataSource" />
    </bean>
    
    <!-- 레퍼런스할 DataSource객체 -->
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://121.127.154.10:3306/hoseok" />
        <property name="username" value="hoseok" />
        <property name="password" value="!dlghtjr4948" />
    </bean>

	> 기존의 noticeService객체에 DI를 해야함
	> 꽂기위한 Dependency로 dataSource이름의 DriverManagerDataSource를 생성해야 한다.
	> dataSource는 JDBCNoticeService에서 제거한 Driver, URL, UID, PWD값을 setting 해야한다(setter)
	> 이후 세팅된 dataSource를 JDBCNoticeService객체에 DI해 완료한다.

* 다만 org.springframework.jdbc.datasource.DirverManagerDataSource 클래스를 이용하기 위해서는 라이브러리를 추가해야 한다.
	> pom.xml에 Spring-JDBC 라이브러리를 추가한다.

* 이렇게 DataSource를 분리해봤고 정상적으로 실행됨을 알 수 있다.





< ------------------------------------------------------------ Spring 설정 파일 분리하기 ------------------------------------------------------------ >
* Spring이용시 사용하는 HandlerMapping역할의 xml파일을 분리하자
* 현재 xml파일은 /WEB-INF/dispatcher-servlet.xml로 정해진 이름과 정해진 위치에 두었다.
	> 파일을 다른 위치에 두거나 이름 형식이 *-servlet.xml이 아니면 인식이 안됨
	> 그렇지만 설정파일을 꼭 이곳에 두어야 하는것은 아니다(원하면 파일명, 위치 모두 변경 가능)
* 따라서 정해진 이름이 아닌 원하는 위치에 원하는 파일로 만들 수 있다.
* 하나로 되어있는 파일을 여러개로 나누어 보자
	> 여러개로 나뉘므로 폴더를 만들어 담자
	>/WEB-INF/spring/ 경로를 생성해 기존의 dispatcher-servlet.xml파일을 내용을 지우고 spring/아래에 3개를 복사한다.

* 3개의 파일들을 각각 아래와 같이 지정한다.
	> servlet-context.xml : 서블릿과 관련된 설정 내용 담음
	> service-context.xml : 서비스 관련된 설정 내용 담음
	> security-context.xml : 보안 관련된 설정 내용 담음
	
	> 여기서 파일명은 정해져 있는것은 아니고 사용자 마음대로 가능하다.
	> 그렇다면 3개로 나눈 이유는 무엇인가?

* 기존의 dispatcher-servlet.xml에 담긴 내용을 3개로 분리하기 위함, 왜?
	> 프로젝트를 진행하다 보면 여러 사람이 참여하는 경우가 많다.
	> 이때 역할을 나누며 설정파일을 다룰때 한 개의 설정파일을 이용하다보면 다른 사람이 완료될때까지 기다림(동기화)
	> 동기화가 많아지면 파일이 문제를 발생시킬 수 있는 접점이 생긴다.
	> 따라서 자기의 설정을 따로 가지고 있는것이 바람직하다.
	> 혼자 만든다 하더라도 3개로 설정을 분리하면 좀 더 정리가 된다.
	> 추가로 역할자가 어떻게 나누어지냐에따라 파일을 추가할수도 있다.
	> 기본적인 패턴은 위 3가지가 가져가기 때문에 만들어놓고, 필요에따라 환경에 맞게 나누면 된다.

* service-context.xml (서비스 관련 설정) 설정하기
	> 서비스 관련 빈은 2개가 전부
    <!-- NoticeService bean 생성(객체화 되어 IoC Container에 담겨지게 된다.) -->
    <bean id="noticeService" class="com.hoseok.web.service.jdbc.JDBCNoticeService">
        <!-- DB연결정보 객체 DI -->
        <property name="dataSource" ref="dataSource" />
    </bean>

    <!-- 레퍼런스할 DataSource객체 -->
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver" />
        <property name="url" value="jdbc:mysql://127.0.0.1:3306/hoseok" />
        <property name="username" value="hoseok" />
        <property name="password" value="!dlghtjr4948" />
    </bean>

* servlet-context.xml (서블릿 관련 설정) 설정하기
	> 위의 2개를 제외한 나머지 부분들은 서블릿 설정과 관련된 내용

* security설정은 아직 적용하지 않았으므로 설정할것이 없다.

* 기존의 dispatcher-servlet.xml은 후에 이 설정을 사용하지 않도록 변경할것이므로 지우지 않아도 문제가 되진 않는다.
	> 굳이 걱정되면 확장자를 변경해 xml로서의 의미를 없애서 사용하지 못하도록 한다.

* web.xml에서 우리가 지정한 설정파일의 위치 지정하기
	> 기존에는 설정파일이 어디있는지 알려주지 않았으므로 기본적으로 약속된 위치로 세팅이 되어있다. /WEB-INF/
	> 우리는 디렉토리와 설정파일이 변경되었으므로 알려주어야 한다.

	<init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/spring/servlet-context.xml</param-value>
		
	</init-param>
	> param-name은 DispatcherServlet에서 넘겨받을때 사용하는 setter와 같은 이름이다.(DispatcherServlet이 정의해놓은 이름이다)
	  따라서 스펠링이 틀리면 안된다.
	> contextConfigLocation : IoC Container의 설정파일의 위치, xml입력 하거나 개발자가 정의한 Java Class파일 정의가능
	> param-value은 web root로 부터 시작되는 context파일을 설정할 수 있다.

* 하지만 위의 설정에선 xml파일을 하나만 지정가능하다 두 개 이상의 파일을 지정하고 싶으면 Spring이 지정하는 ContextLoaderListener를 이용한다.

* Listener 란
	> Servlet의 Listener는 웹어플리케이션의 주요 변화를 감지하고 특정 이벤트가 발생했을때 특별한 작업을 처리하도록 할 수 있다.
	> Tomcat이 시작되거나 끝날때 Session이 시작되고 끝날때 무엇인가 이벤트를 감지하고 특정 작업을 처리한다.
* org.springframework.web.context.ContextLoaderListener란
	> 사용자가 계층별로 xml 설정파일을 나눴을때 web.xml에서 모두 load되도록 xml파일 등록시에 사용된다.
	> 서블릿 이전에 서블릿을 초기화 하는 용도로 사용되며 contextConfigLocation로 param-name을 이용하면 Context Loader가 load할 수 있는파일을 여러개 작성가능
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>
	> 위와 같이 설정하면 웹 애플리케이션이 시작할 때 자동으로 루트 애플리케이션 컨텍스트를 만들고 초기화 해 줍니다.
	  디폴트 값으로
	  컨텍스트 클래스는 XmlWebApplicationContext 를 만들고 
	  설정파일 위치는 /WEB-INF/applicationContext.xml 입니다.

* ContextLoaderListener는 DispatcherServletContext가 가져다 이용할 수 있다.
* 리스너는 가지게 될 기본적인 parameter값을 <context-param>이 있다.(listener를 이용할때)
	> 나머지 xml파일들을 파라미터 설정으로 등록하면 DispatcherServlet이 가져다 사용된다.

	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>
			/WEB-INF/spring/service-context.xml
			/WEB-INF/spring/security-context.xml
		</param-value>
	</context-param>

* 파일을 3개로 나누었다 이후 실행하면 잘 동작된다.
* 다만 Servlet을 사용할 때 DispatcherServlet이 언제 메모리에 올라가는지 볼 필요가 있다.
	> 모든 Servlet은 URL매핑 되어있고 첫번째 URL요청이 오면 DispatcherServlet이 메모리에 올라간다.
	> 따라서 요청이 올때 메모리에 올라가므로 첫 요청에선 느린 속도를 보인다. --> 미리 올라갈 필요가 있음


* load-on-startup 설정으로 톰캣이 시작될때 DispatcherServlet을 로드하고 하기(메모리에 올라가도록 하기)	
	> <load-on-startup> : startup은 톰캣을 말함
	> <load-on-startup>1</load-on-startup> : 만약 로드할 서블릿이 여러개 있다면 0보다 큰 숫자로 우선순위를 지정할 수 있다.

* 비동기 방식 사용하기
	> 기존의 서블릿을 로드하는 방식은 다른것들과 연관되어 줄서서 하나씩 로드하는 동기식 방식이었지만
	> 만약 비동기식으로 로드하기를 원한다면 <async-supported>true</async-supported>로 작성하게되면 비동기로 작동한다.

* 최종 web.xml
    <!-- ContextLoaderListener설정으로 Context Loader가 load할 수 있는파일을 여러개 작성 -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
    <!-- 다른 XML 설정파일 등록하기 -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>
            /WEB-INF/spring/service-context.xml
            /WEB-INF/spring/security-context.xml
        </param-value>
        
    </context-param>
    <!-- mapping 정보를 넣음 -->
    <servlet>
        <!-- mapping 주소가 서블릿과 연관을 맺기 위해 이름을 정해줘야 한다. -->
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- 우리가 지정한 설정파일의 위치 지정 -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring/servlet-context.xml</param-value>
        </init-param>
        
        <!-- 톰캣이 시작될때 DispatcherServlet을 로드하고 하기(메모리에 올라가도록 하기) -->
        <load-on-startup>1</load-on-startup>
        <!-- 비동기 방식으로 서블릿 로드하기 -->
        <!-- <async-supported>true</async-supported> -->
    </servlet>





< ------------------------------------------------------------ 객체 DI 방식 annotation으로 변경하기 ------------------------------------------------------------ >
* xml설정으로 되어있는 스프링 설정을 annotation으로 변경해보자
	> 서비스 객체 사용시  xml에서 직접 DI 작업을 함
	> 과거 방식에서 최근 스프링 사용방식으로 변경해보자

* Spring을 떠나 Java application은 두 가지 방법으로 설정방식을 사용
	1. xml파일을 이용해 외부 설정을 함
	2. annotation을 사용해 설정

	> 둘의 장단점이 있지만 Spring은 annotation과 Java설정으로 변경하려고 함
	> 외부 텍스트 파일을 이용해도 더 경량화된 것을 사용함

* Service object DI 방식 부분 annotation으로 변경하기
	> 우선 3개의 설정파일중 servlet-context.xml을 annotation으로 변경하기

* servlet-context.xml에서 ListController bean : <property name="noticeService" ref="noticeService" /> 로 DI하는 부분을 지우고 annotation으로 변경해보자
	> ListController에서 setter위에 @Autowired를 작성함 (이런 작업은 소스코드를 수정할 수 있는 프로젝트에서만 가능)
	     @Autowired
            public void setNoticeService(NoticeService noticeService) {
                this.noticeService = noticeService;
            }

	> 이후 servlet-context.xml설정에 context namespace를 추가한다.
	> xsi:schemaLocation에 http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd 를  추가하고
	> xmlns:context에 http://www.springframework.org/schema/context 추가하면 context namespace를 이용할 수 있다.

* 이후 <context:annotation-config /> 를 작성하면 실제로 소스코드에서 annotation을 찾아 동작한다.
* context:annotation-config
	> ApplicationContext 안에 이미 등록된 bean들의 Annotation을 활성화 하기 위해 사용된다.
	> bean들이 XML로 등록됐는지 혹은 패키지 스캐닝을 통해 등록됐는지는 중요하지 않다.
	> 이미 스프링 컨텍스트에 의해 생성되어 저장된 bean들에 대해서 @Autowired와 @Qualifier Annotation을 인식할 수 있다.
	> component-scan 또한 같은 일을 할 수 있는데, context:annotation-config는 bean을 등록하는 작업을 하지 않는다.
	> 즉, bean을 등록하기 위해 패키지를 안의 클래스를 스캔할 수 없다.
	> 이 태그를 설정하면 @Required @Autowired @Resource @PostConstruct @PreDestroy @Configuration 기능을 각각 설정하지 않아도 된다.

* @Autowired위치 
	> setter, 필드, 생성자 모두 가능하다
	> setter : DI말고 다른것도 수행하고 싶을때 이용 예를들어 setter내부에서 System.out.println()으로 콘솔에 출력한다던지
	> 필드 : 다른 수행할 수 있는 기능이없고 오직 DI만 auto로 해줌

* 굳이 세팅외 다른것을 할 여지가 없다면 필드위에 어노테이션을 두고 setter쪽 어노테이션을 지우는것이 간결하고 좋아보임


* service-context.xml에서 DI annotation변경
	> noticeService 빈에 dataSource를 DI하는 부분
	> xml에서 context namespace설정과 context:annotation-config태그로 어노테이션을 이용함을 알려주고

	> 기존의 dataSource를 DI하는 property태그를 지우고 JDBCNoticeService.java에서 setter를 지우고 필드위에 @Autowired를 달아준다





< ------------------------------------------------------------ Annotation으로 서비스 객체 생성하기 ------------------------------------------------------------ >
* noticeService bean을 주석처리
	> 이후 JDBCNoticeService에 @Component 어노테이션을 단다.
	> 하지만 컴포넌트를 발견해야 하므로 뒤져볼 공간을 찾을 수 있도록 패키지를 알려줘야한다. 그래야 스캔후 IoC Container에 담김
	> service-context.xml에서 context:component-scan base-package="com.hoseok.web.service"을 달아준다.

* component-scan의 역할
	> 패키지를 지정해주면 지정된 패키지를 뒤져보면서 @Component 어노테이션을 찾아서 찾게되면 객체를 생성한다.
	> 이를 설정하게 되면 객체화 하면서 그 안쪽에 있는 어노테이션이 또 어떤것이 있는지 찾게됨
	> 따라서 context:annotation-config의 기능이 포함되어있으므로 지워줘도 됨
	> 이후 실행하면 잘 동작

* Component는 범용적인 의미로 사용되므로 의미적으로 특화되어있는 annotation을 사용해야함
	> @Component태그의 종류
	> @Controller, @Service, @Repository : 조금 더 의미론적이고 시멘틱한 주석 --> 역할이 분명하게 보임

* Service를 객체를 만듦, 서비스를 생성하는것은 컨트롤러임 따라서 컨트롤러 설정도 annotation으로 변경해보자
	> Controller생성시 url mapping존재 이것도 annotation으로 변경하기
	> 이렇게 설정을줄이게 되면 결국 boot를 사용해 설정을 더 줄일 수 있다.






< ------------------------------------------------------------ Annotation으로 URL매핑하기 ------------------------------------------------------------ >
* 서비스 객체를 Annotation을 이용해 객체화함
* Controller를 annotation을 이용해 객체화 해보자

* servlet-context.xml에서 IndexController bean을 주석처리하고 Controller에 @Controller어노테이션을 붙인다
	> 클래스를 로드할 수 있고 IoC Container에 객체화 해서 담아놓는다.

* 이후 servlet-context설정에서  context:component-scan을 이용하고 context:annotation-config를 지운다.(component-scan시 annotation-config동작도 하므로)
* 의문점: 만약 컴포넌트 스캔범위(base-package)를 com.hoseok.web까지 범위를 늘리면 각각의 설정파일중 하나만 설정해놓으면 되지 않나?
	> 스캔범위가 넓어지면 모든 클래스들을 전부 찾아야함
	> web/안에 패키지들이 한두개가 아니므로 모든것들이 IoC 컨테이너에 담아야할 객체들은 아니다. --> 성능상의 문제
	> 따라서 컨트롤러, 서비스 등 따로따로 설정해주는것이 바람직하다.

* 컨트롤러는 URL에 응답하므로 URL에 대한 정보도 심어줘야 한다.
	> annotation으로 적용하는 URL매핑은 큰 장점을 가지고 있다.
	> annotation은 클래스를 그냥 찾게된다.(뒤져서 어떤 함수에 annotation이 붙으면 실행하고, 혹은 클래스에 특정 어노테이션이 붙으면 객체를 생성함(@Component))
	> 즉 특정 어노테이션이 붙어있으면 붙어있는걸 가지고 해야할 행위들이 존재함
	> 이전의 방식은 컨트롤러를 객체화해도 객체를 참조하기 위해선 참조하기 위한 변수명, 호출할 수 있는 함수(handleRequest()), 인터페이스와 같은 규약 필요(implements Controller)
	> annotation을 이용하면 이런 규약들에 얽메이지 않으므로 지워도 됨
	> 내부에 구현한 handleRequest()도 Controller인터페이스를 상속받게되어 구현했어야 하는 메소드 였으므로 annotation으로 사용하게되면 지워도 됨.

* Index 컨트롤러에 URL 매핑하기
	> 기존에 Controller인터페이스를 상속받는 부분을 지운다. 또한 handleRequest()메소드도 구현 할 필요가 없으므로 지움 이후 @Controller로 클래스를 어노테이션 처리한다.
	> 따로 약속된 메소드 생성이 없으므로 사용자가 원하는 이름의 메소드가 생성가능함 일단 aaa()메소드를 임의 구현해보자
	> 메소드를 생성하고 메소드에 @RequestMapping("/index")로 어노테이션을 매핑해준다.
	> 하지만 콘솔출력입력하고 실행하면 404에러 발생
	@Controller
	public class IndexController {
    
    		@RequestMapping("/index")
    		public void aaa() {
        		System.out.println("hello");
    		}
	}

* URL매핑(RequestMapping)을 위한 설정 mvc:annotation-driven
	> @Controller : IndexController를 메모리에 올리는 작업은 기존의 context:component-scan 설정으로 충분함
	> @RequestMapping : 컨트롤러를 메모리에 올리고 매핑을 하는 작업은 또다른 설정이 필요하다.
	  mvc:annotaion-driven 설정을 해당 설정파일에 작성한다 이는 사용자 요청을 수반할 수 있도록하는 역할을 한다.
	 이를 설정하지 않으면 @RequestMapping이 제 역할을 하지 못한다.

* 설정완료하고 실행
	> IndexController를 실행하면 페이지도 출력되고 콘솔도 hello란 글자가 출력됨
	> 또한 view정보를 전달하지 않고 void함수가 실행됐지만 RequestMapping의 URL을 가지고 ViewResolve작업을 실행한다.
	  (일반 URL이므로 Tiles ViewResolver가 아닌 2순위 일반 ViewResolver 실행됨)
	> 뷰리졸버의 동작확인을 위해 임의로 매핑을 aaa로 변경하면 URL기반으로 /WEB-INF/viwe/aaa.jsp를 못찾는다는 오류 발생(404)
	> 따라서 /index를 매핑하면 찾은 페이지가 있지만 Tiles설정을 인해 조각나 있으므로 main부분만 출력된다.

* 요즘은 이런방식으로 이용, 다음시간에는 컨트롤러의 잘못된 이름을 변경해보자





< ------------------------------------------------------------ HomeController 만들기 ------------------------------------------------------------ >
* IndexController를 만들며 annotation을 적용하는것에 포커스를 맞춤
* 하지만 변경된 컨트롤러가 컨트롤러의 형태가 아니게 만들어졌다. 따라서 IndexController를 컨트롤러 답게 내용을 고쳐보자

* 약 3가지의 고쳐야 할 점이 있다.
	1. IndexController가 더이상 URL매핑되는 것이 아니므로 이것을 어떻게 위치시켜야할지
	2. 기존에 Model(data), View라는 페이지를 tiles를 이용해 심었다, 이런 view를 심는방법에 대해 알아보자
	  (물론 이전시간에 URL에 맞게 묵시적으로 view를 찾았지만 Tiles를 이용하므로 Tiles를 이용한다) 
	  따라서 Tiles를이용해 원래 페이지를 나오게 하자
	3. model을 전달하고 view에서 출력하기

1. 더이상 URL은 클래스에 매핑되지 않는다.
	* 기존의 설정파일에서 클래스와 URL을 매핑시켰지만 현재 URL은 메소드와 매핑된다.
	* 이전에는 클래스 하나에 하나의 메소드가 있었고 메소드에 URL이 매핑되었지만
	* 이제는 클래스 하나에 여러개의 메소드가 와도 각각 다르게 매핑이 가능하다.(메소드의 이름이 다르고 다른 URL을 매핑하면 가능)

	* 결국 IndexController는 컨트롤러를 담는 더 큰 그릇이 되고 각 메소드들이 Controller가 된다.
		> 따라서 Index라는 이름으로 한정지어선 안되고 Index라는 컨트롤러를 포함하고 있는 더 큰의미의 그릇으로서의 이름을 가져야함	
		> IndexController는 root(홈디렉토리)에 존재하는 view를 담당하는 컨트롤러이므로 컨트롤러의 이름을 폴더개념으로 생각하면 된다.

	* 따라서 RootController 혹은 HomeController가 적합해진다
		> Root폴더에 있는 컨트롤러를 담는 그릇 혹은 Home 디렉토리에 존재하는 컨트롤러를 담는 그릇의 의미를 가짐.

	* 기존 임의로 지은 메소드 이름도 URL과 맞춰주어 작성하는것이 바람직하다.

	* 결국 notice아래에 컨트롤러들도 위와같이 변경하게 되면
		> NoticeController.java 아래에 detail.jsp, list.jsp관련된 컨트롤러 메소드를 만들고 알맞은 URL을 매핑하는것이 바람직하다.


2. 컨트롤러를 담당하는 메소드들은 view정보를 전달해야한다.
	* 기존에는 Model, View를 담는 그릇을 만들어 반환했지만, annotation에선 방법이 달라짐
	* view를 반환하기 위해선 반환타입을 String으로 두고 return으로 view의 정보를 반환한다 (ex: return "root.index";)
	  /index는 묵시적으로 리소스를 만들어 찾게되고 root.index는 tiles에서 resolving이 가능하므로 조합된 페이지가 출력된다.


* 클래스는 더이상 컨트롤러가 아니라 컨트롤러를 담는 Container의 역할로써 사용
* view페이지를 만들기 위해서 단순히 문자열을 반환하는 방식으로 하면 간단히 view를 찾을 수 있다.













