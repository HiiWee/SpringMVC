< ------------------------------------------------------------ Spring MVC ------------------------------------------------------------ >

* Spring을 사용하지 않고 Tomcat(Tomcat Configuration)을 이용해 웹개발 가능(Servlet, JSP)
	> 이때는 web.xml을 사용 : 사용할 라이브러리 인스턴스화(Mybatis, Tiles) 등등의 설정
	> Spring을 사용하겠다 하면 이곳에 Spring을 얹음(Spring Dispatcher) : Spring Web 개발시 Spring Dispatcher 라이브러리를 기반으로 사용

* Spring Dispatcher
	> Controller의 공통분모를 모아놓은 Front Controller를 Spring에서 제공해줌 : 그게 Spring MVC다.
	> Spring MVC를 쓰겠다면 Spring이 거의 모든것을 커버함 -> Spring을 쓰기위한 또다른 설정이 필요함 : Spring Configuration

* Spring Web : Spring Configuration이 늘어남
	> 톰캣의 web.xml 설정에서 옮겨짐 : Spring Config가 라이브러리 기타 등등을 관리하게 됨 (Mybatis, Tiles등)
	> 또한 Spring Configuration에는 일반적으로 자신만의 설정인 Servlet, Service, Security설정들이 더 추가 됨

* 결국 톰캣, 톰캣설정, 스프링, 스프링 설정 하는 방법들을 알아야함
	> Spring 버전이 변화하며 설정방법도 변화하기 시작함
		> XML, Annotation, Java등 다양한 방법 존재

* 최근에는 이러한 설정에 대한것들을 도와줄 수 있는 Spring Boot가 나옴
	> Spring MVC를 대신하기보단 설정에 대한것들을 모아서 편하게 해줄 수 있는 부가적인 프레임워크

* Spring에 Spring Boot를 얹어서 사용하게 되면 기존의 복잡한 설정을 피할수 있게 된다.
	> Stater Configuration을 필요로하는 각각의 설정들을 한번에 묶어서 라이브러리로 가지고 있다 -> 설정에 대한 라이브러리를 일일이 설정할 필요가 없다.
	> 최대한 설정을 줄이고 설정파일 하나만 둠 applicaiton.properties(단순 텍스트파일) 혹은 YAML(Json같은 형태의 표기법파일)의 설정파일 중 골라서 사용함 (주로 application.properties사용)

* Spring Boot를 사용하게 되면 결국 설정에 대한 부분이 크게 줄어든다.





< ------------------------------------------------------------ Spring MVC란 ------------------------------------------------------------ >
* Spring을 이용해서 웹 개발을 해보자

* 기존 MVC model2 방식
	> Controller : servlet, View : jsp 로 나눔 forwarding을 dispatcher를 이용해 구현함
	> 하지만 위와같이 되며 모든 Controller는 Dispatcher를 가지게 됨 --> 비효율적

* 기존 MVC model2 방식의 변화 : Dispatcher를 집중화 한 후의 모델
	> 순수하게 Controller의 기능만 구현시킴 --> 이것은 Servlet이 아니라 일반적인 자바 클래스(POJO:Plain Old Java Object)로 구현함
	> 기존 Controller로 이용하던 Servlet은 dispatcher기능만 남아있다 --> 이는 forwarding하는 기능이므로 거의 기능이 똑같음 --> 하나만 남김(디스패처의 집중화)
	> 사용자의 요청을 컨트롤러에 전달하고 요청한 결과물을 받아서 다시 view에게 전달함 (중간매개의 역할) 매우 중요한 역할

* dispatcher의 역할 
	> 사용자의 요청을 받는다는것의 의미 : 단순 요청 라우팅이아니라 사용자 입력을 쉽게 컨트롤러로 전달해줌
	> 그렇게되면 dispatcher는 servlet api를 이용해 파라미터를 받아오는 등의 서블릿의 기능을 차단해주는 역할
	> Controller에 기본적 사용할 수 있는 String, int등으로 전달해줌 혹은 객체화된 데이터로 담아서 줄 수 도있다.
	> 결국 Controller에선 Servlet 라이브러리를 하나도 사용하지 않고도 입력을 처리하게 되거나,
	  Controller가 데이터를 마련해 view로 전달하려 해도 dispatcher기능이 없으므로 디스패처가 컨트롤러에게 요청을 다시 돌려받게 되는데
	  그 때 Controller에서 어떤 view 페이지가 필요하다는 view페이지 정보만 알려주면 디스패처가 view페이지를 호출하게됨 따라서 서블릿 기능을 dispatcher로 한정한다.
	> 이게 바로 dispatcher를 따로 분리하는 이유

* 따라서 dispatcher는 서블릿, 톰캣, was라고 하는것과 Controller와 결합력을 낮추게 하며 컨트롤러를 혹시 다른 환경에서도 쓸수있게 할수있다.

* 결국 front controller(dispatcher)를 만드는것이 중요하며 만드는 것을 Spring이 제공함
	> Spring이 제공하는 front controller 라이브러리를 이용해 Controller를 만듦
	> front controller를 잘 만들게 되면 톰캣과 이별 할 수 도있게 웹개발 할 수 있다.

* Dispatcher역할을 가지고 있는 Dispatcher servlet(Spring 제공하는 기능)에 여러 URL이 옴
	> 모든 URL을 받아서 처리해야 한다.
	> 모든 URL요청이 오게됨 --> 그것을 적절히 알맞은 Controller에게 배분해야함 --> URL에 대한 정보를 어떤 Controller가 처리할지 가지고 있어야한다.
	> 따라서 Spring이 제공하는 Dispatcher 관련된 front controller 라이브러리 사용시 설정파일이 필요하다.
		> 과거엔 url매핑, 어노테이션으로 설정했으나 그 내용이 *-servlet.xml로 옮겨진다.
		> 즉 web.xml은 모든 url이 dispatcher servlet로 향하게 함,
		  이것을 알맞은 Controller에게 배분하기 위해 dispatcher servlet 설정파일에서 매핑 정보를 쓰게된다(*-servlet.xml)
	> 어떻게 보면 톰캣의 매핑정보가 스프링위로 올라간것 뿐으로 보인다. 하지만 결합력을 낮추는 부분에서 장점이 있음

여담 : 과거에는 Dispatcher Servlet을 직접 만듦 --> 요즘은 Spring것을 사용 --> Spring에 종속되는 문제 야기
	> 방법론으로 발전시켜나가는게 바람직해보임 --> 가능하면 개별적으로 만들어가며 실력을 키우는것도 좋아보입니다.

* Controller는 반환할 때 model, view의 정보를 전달함 --> dispatcher가 요청시 반환받은 두 개의 값을 가지고 view를 찾아서 관련된 데이터(Model)을 전달함
	> 즉 Spring MVC는 dispatcher servlet 라이브러리를 사용하는 것이다.





< ------------------------------------------------------------ 실습환경 준비하기 ------------------------------------------------------------ >
* spring.io에 Spring Tools 4 for Eclipse를 다운받는다.
* apache 9 다운로드 (Spring Boot는 내장 톰캣이 존재해서 따로 다운받을 필요 없음)

* 이후 다운받은 Spring Tools 4 for Eclipse를 압축풀고 내부에 contents 알집을 압축을 푼다
	> sts-4.13.0.RELEASE를 잘라내서 tools 파일로 옮김

* 이후 SpringToolSuite4.exe파일을 실행한다.




< ------------------------------------------------------------ 메이븐을 이용한 기본 웹 프로젝트 생성하기 ------------------------------------------------------------ >
* Create new Spring Starter Project == Spring Boot 이용
* 우리는 legacy Spring 이용 웹 프로젝트를 Maven 기반으로 생성해야함 --> Java EE 툴 설치

* 메이븐 프로젝트 생성
	> Group id : com.hoseok
	> Artifact id : webPrj
	> Packaging : war

* pom.xml에 web.xml이 없다는 오류가 발생하므로 apache tomcat에 ROOT/WEB-INF 폴더에서 web.xml을 가져옴
	> 추가로 오류 발생시 --> maven-war-plugin을 3버전 이상으로 임의로 플러그인 추가해줌

* JDK 버전 올리기
	> 1. pom.xml -> overview -> Properties : name=maven.compiler.source, value=1.8 추가 그리고 name=maven.compiler.target, value=1.8로 등록함 이후 update project

* JSP 파일 추가시 오류 발생
	> pom.xml에 tomcat api 추가 해줘야함 구글에 tomcat-api 검색해서 맞는 버전의 dependency 코드 긁어오기
	> 혹은 pom.xml하단에 dependencies -> add 이후 검색해서 추가하기도 가능 (Global Repository rebuild작업해야 검색가능)

* 이후 실행하고 tomcat 홈 디렉토리 등록하고 실행하면 실행된다.

* 이제 MVC 방식으로 변경해야한다




< ------------------------------------------------------------ Dispatcher Servlet 라이브러리 설정하기 ------------------------------------------------------------ >
* Spring Dispatcher를 Front 컨트롤러로 설정해야함.

* 기존에 컨트롤러와 디스패처를 같이 사용했지만 이것을 분리해 디스패처에 서블릿관련 코드를 두고 컨트롤러는 POJO 클래스로 만들기로 함

* 디스패처 서블릿은 DispatcherServlet.class를 이용한다. 이것을 다운로드 받아야함
	> 이전에 구글 tomcat api를 받아온것은 Global Repo -> Local Repo로 받아온것이다.
	> 따라서 직접 Global Repo에서 받아올 수 있다. 다만 Rebuild Index로 업데이트 이후 검색해서 사용가능(pom.xml:Dependencies -> Add -> 검색
		> 이렇게 되면 검색한것을 원격에서 가져와서 로컬로 저장함

	> 두번째로 tomcat api 검색후 Spring web MVC 검색해서 복사해서 dependency 입력


* Maven Dependencies : Local Repo에 있는 내용중 참조하고 있는 라이브러리 목록을 보여줌
	> 여기서 Spring-webmvc -> org.springframework.web.servlet -> DispatcherServlet.class를 우클릭후 Copy Qualified Name 클릭
	> 이렇게하면 패키지명과 클래스명을 한번에 받아올 수 있다.

* 위에서 복사한 내용(front controller 역할을 하는 서블릿 클래스)을 web.xml에서 설정한다.




< ------------------------------------------------------------ dispatcher-servlet.xml 파일 설정 ------------------------------------------------------------ >
* 기존에 MVC 구현하는 방식
	> View(JSP), Controller(extends HttpServlet)
	> view에 controller로 받아온 Model을 심음


* 하지만 SpringMVC에선 컨트롤러에서 서블릿을 이용하지 않을것이다.
	> Controller : POJO
	> Dispatcher : 이미 만들어져 있음(DispatcherServlet.class)

	> 따라서 지금껏 Servlet 프로그래밍을 할 땐 URL 매핑으로 Annotation을 사용했으나
	  DispatcherServlet.class는 남이 만든 서블릿을 설정하는 것이므고 소스를 가지고 있지 않으므로 XML을 이용해 설정할 수 밖에 없다.

* Dispatcher에 URL매핑을 할때는 web.xml에 하게된다. URL 매핑하기
	> Spring-webmvc -> org.springframework.web.servlet -> DispatcherServlet.class를 우클릭후 Copy Qualified Name 클릭
	> 이후 모든 URL을 Front Controller로 받기 위한 Servlet Mapping을 설정한다.
		<!-- mapping 정보를 넣음 -->
		<servlet>
		   <!-- mapping 주소가 서블릿과 연관을 맺기 위해 이름을 정해줘야 한다. -->
		   <servlet-name>dispatcher</servlet-name>
		   <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		</servlet>
	
		<!--
    	   	 front controller이므로 모든 URL을 만나면 위의 DispatcherServlet 클래스를 실행 
    	   	 이후 어떤 URL은 어떤 POJO클래스가 맞는지 분배하는 동작을 함 
   		 -->
		<servlet-mapping>
		   <servlet-name>dispatcher</servlet-name>
		   <!-- /이렇게만 작성하면 모든 URL이 통과되지만 /*로 작성하면 예외없이 모든 URL을 front controller가 받음 -->      
		   <url-pattern>/*</url-pattern>        
		</servlet-mapping>

	> 다음으로 아무 jsp파일을 실행하면 오류가 발생 
		IOException parsing XML document from ServletContext resource [/WEB-INF/dispatcher-servlet.xml]; 
		nested exception is java.io.FileNotFoundException: Could not open ServletContext resource [/WEB-INF/dispatcher-servlet.xml]

	> 우리는 현재 Dispatcher를 이용하려고 함 (모든 URL에 대해 요청을 받겠다.)
	> 현재 index.jsp를 요청했을때 어떤 URL이든 dispatcher가 받았다. 이후 dispatcher가 적절한 URL에 맞는 리소스를 배포해야 한다.
	> 하지만 그런 매핑 정보 즉 dispatcher가 어떤 페이지를 열것인지에 대한 정보는 *-servlet.xml 파일이 가지고있다.
	> 그리고 파일이 매핑정보를 가지고 있어야 오류가 나지 않음 따라서 /WEB-INF/*-servlet.xml을 생성하고 매핑을 설정해야함(원하면 설정으로 다른위치로 변경 가능)
 
	> 정리하면 모든 URL을 front controller로 받아왔으나 이후 어떤 POJO 클래스에 뿌려질건지에 대한 URL 매핑정보가 없어서 발생한다.
	> 이는 /WEB-INF/dispatcher-servlet.xml에 저장되어있고 우리가 servlet-name을 어떤걸로 정하느냐에 따라 xml파일 이름이 결정된다.(주로 dispatcher이용)


* 매핑 정보는 어떻게 넣을까?




< ------------------------------------------------------------ 스프링 컨트롤러 IndexController 작성하기 ------------------------------------------------------------ >
* Spring이 제공하는 MVC 지원 라이브러리(dispatcher lib)의 설정파일인 dispatcher-servlet.xml파일 작성하고 Index Controller 만들기
* 어떤 구문으로 만들어야 하는지 우리는 알 수 없다.
	> 이것을 제공해주는 Spring의 공식문서에서 레퍼런스 참조하기
	  https://docs.spring.io/spring-framework/docs/ 이곳에서 맞는 버전의 공식문서를 살펴봄 (core 목록 누르면 DI를 공부할 때 봤던 xml설정내용 보임)

* 기존의 Spring은 beans태그 안에서 bean태그를 이용해 설정해 어떤 클래스를 설정하면 이를 객체화해서(id=변수명, class=어떤클래스) IoC Container에 담게된다.
* 하지만 MVC에서 *-servlet.xml 설정파일은 id값이 변수명이 아니라 URL로 사용된다. 
  (컨테이너 담겨있는 객체들 중에서 사용자 요청이 URL로 옴, 그 URL을 가지고 IoC Container에서 꺼냄 무엇을? class속성에 있는 클래스로 된 객체를)

	<bean id="/index" class="com.hoseok.web.controller.IndexController">
		<!-- collaborators and configuration for this bean go here -->
	</bean>

* 이제 남은것은 Spring의 Dispatcher 클래스가 IndexController에서 컨테이너에서 꺼내고 가지고 있는 기능을 호출해야함
	> URL과 Controller를 매핑하는 정보를 id를 이용해 URL을 쓰는데 이게 bean 형태로 컨테이너에 담겨있음
	> 문제는 frontController에서 Controller를 사용하기 위해서는 요청을 수반할 수 있는 약속된 무엇 즉 기능이 있어야함
	> 약속된 함수명을 사용해야 한다. : handleRequest

* 모든 컨트롤러는 디스패처가 정의해놓은 함수를 사용해야 함, Controller interface 타입
	> POJO클래스가 이전에는 Servlet에 종속되어 있었지만 이제는 Dispatcher-Servlet에 종속되어 있다.

	public class IndexController implements Controller {

   		@Override
   		public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
   	     		// TODO Auto-generated method stub
   	    		return null;
  	  	}

	}

* 위에 Dispatch기능은 빠져있다(Spring이 제공) 따라서 함수가 반환하는 값은 Dispatch를 하기위한 ModelAndView를 반환한다.
	> ModelAndView객체를 생성해 어떤 모델을 전달하고 어떤 view에 전달할지 값을 설정하고 ModelAndview객체를 반환한다.
	public class IndexController implements Controller {

	    @Override
	    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        
        	ModelAndView mv = new ModelAndView();
        
        	// data키워드를 가진 String data를 담음 -> Model을 data란 이름으로 담아서 저장
        	mv.addObject("data", "Hello Spring MVC~");
        	// view에 대한 정보를 담음, 두가지 방법이 있다.
            	// 1. view 객체를 따로 만들어서 설정 : mv.setView(View view);
            	// 2. view의 이름만 담아서 설정 : mv.setViewName(@Nullable String viewName);
        	mv.setViewName("index.jsp");
        
        	return mv;
    	   }

	}

* model을 반환하고 나서의 실행 순서
	1. Model and View를 Dispatcher-Servlet으로 반환
	2. Dispatcher-Serlvet이 view로 Forwarding을 해 Model전달
	3. View는 출력할때 model을 사용해 사용자에게 보여줌

* 실제 IndexController를 실행하면 404오류 발생, 왜 그럴까?
	> tomcat을 이용해 tomcat Annotation을 사용할땐 매핑주소를 잘 써주지만 POJO클래스이므로(톰캣이 모름) 주소를 소스코드를 반환해버림
* 그래서 http://localhost:8080/webPrj/index로 직접 입력해 접속해도 404오류 발생 왜?
	1. IndexController를 실행하고 url에 http://localhost:8080/webPrj/index를 실행
	2. web.xml에 설정한대로 Front-Controller가 모든 URL을 받고 약속된 *-servlet.xml에서 어떤 컨트롤러를 실행할지 찾음 따라서 IndexController실행함
	3. IndexController에서 view이름을 설정하고나서 mv.setViewName("index.jsp"); 이후 포워딩하게되는 부분도 결국 하나의 요청임
	4. DispatcherServlet에선 이를 다시 받아서 *-servlet.xml로 보냄
	5. 하지만 inde.jsp로 지정된 url이 없으므로 404 오류 발생

* 여기서 기존의 web.xml설정이 위와같은 문제를 야기함
	<servlet-mapping>
	   <servlet-name>dispatcher</servlet-name>
	   <!-- /이렇게만 작성하면 모든 URL이 통과되지만 /*로 작성하면 예외없이 모든 URL을 front controller가 받음 -->      
	   <url-pattern>/*</url-pattern>
	</servlet-mapping>
	
	> url-pattern에서 /* 별표까지 쓰게 되면 어떠한 요청(forwarding이든 get요청이든)도 무조건 dispatcher를 거쳐서 지나감.
	> 결국 index.jsp를 포워딩하는 부분에서 다시 DispatcherServlet로 전달되고 *-servlet.xml 파일에서 url-mapping을 찾으므로 404오류가 발생한다.

* 결국 url-pattern에서 /* -> /로 변경
	> 이렇게 하면 DispatcherServlet을 거쳐서 dispatcher-servlet.xml에서 매핑정보를 찾지만
	> dispatcher-servlet.xml에서 리소스 정보를 찾지만 없게되면 그냥 리소스를 직접 요청함

* 이후 실행하고 URL을 요청하면 정상적으로 페이지 출력
* 하지만 *를 지우게 되면서 발생되는 문제점이 존재한다.




< ------------------------------------------------------------ View 페이지를 위한 위치 ------------------------------------------------------------ >
* url-pattern에서 /* -> /로 변경하게 되면 문제점이 발생함
	> 일단 Controller와 View가 있다. 하지만 이를 실제 Application에서 보면 하나로 생각한다.
	> 즉 사용자 요청이 왔을때 따로 요청이 오는것이 아닌 무조건 Controller를 요청하게 해야함
	> 하지만 /* -> /로 변경되면 Controller를 건너뛰고 index.jsp를 직접 요청하는일이 가능해진다.

* 따라서 애초에 View페이지를 직접접근할 수 없게끔 WEB-INF/ 경로에 숨겨놓음 이곳은 사용자가 직접 접근할 수 없는 영역임.
* 다행히도 Controller에선 접근 가능 
	> 클라이언트 접근을 막았지 서버쪽에서 파일을 요청하는것은 허락됨

* 따라서 기존에 viewName을 setting하는 작업의 URL을 변경해준다. mv.setViewName("/WEB-INF/view/index.jsp"); (경로가 길어지지만 해결할 수 있음)
* 이제 View 페이지는 Controller를 통해서만 접근이 가능하다.

* mv.setViewName("/WEB-INF/view/index.jsp");에서 절대경로가 아닌 mv.setViewName("WEB-INF/view/index.jsp"); 상대경로로해도 오류가 나지않음
* 그렇다면 만약 dispatcher-servlet.xml파일의 URL을 /aa/index로 변경하면?
	> http://localhost:8080/webPrj/aa/index 로 요청하면
	> /aa/WEB-INF/view/index.jsp을(를) 찾을 수 없습니다. 라는404 오류 발생, 왜?
	> Controller는 dispatcher-servlet.xml에 의해 http://.../aa/index라는 주소를 가짐
	> 상대경로로 입력하게되면 index라는 주소와 같은 위치에 있다고 판단해 http://.../aa/WEB-INF/view/index.jsp 이렇게 View를 찾게된다.
	> 따라서 이런것을 신경쓰고 싶지 않다면 절대경로를 이용

* 또한 dispatcher-servlet.xml파일에서 url 매핑 이름 정할때는 /를 빼먹으면 안된다. 


* 기존 url을 보면 http://localhost:8080/webPrj/index에서 프로젝트명이 URL에 들어간다.
	> 실제 서비스시 프로젝트명같은 이름은 들어가면 안된다. --> 이는 여러개의 프로젝트를 만들 수 있게 하기 위해 URL에 Context명을 붙여서 그렇다.
	> 따라서 main프로젝트 이므로 Context명을 /(root)로 변경하고 서버에서 싱크된 프로젝트를 지우고 다시 시작한다.

* http://localhost:8080/index로 접속시 index 페이지가 요청이 정상적으로 됨
	> 하지만 controller에서 실행시 index페이지가 나오지 않음(이클립스가 적당한 요청URL로 실제 위치를 요청하므로)
	> 따라서 약간의 편법으로 webapp/index라는 원래 URL구조대로 파일을 만들고 거기서 실행하면 정상적으로 index페이지가 출력된다.
	> 이렇게 되는 이유는 이클립스는 웹 루트에 있는 특정파일을 선택하고 실행하면 그 파일을 브라우저에 써준다.
	> 따라서 이것이 IndexController에 매핑했던 주소와 동일하고 우선순위가 높음
	> 결국 Controller의 URL에 dispatch가 이루어져 기존 페이지가 실행된다.




< ------------------------------------------------------------ ViewResolver 사용하기 ------------------------------------------------------------ >
* 이전에 보안을 위해 View페이지를 WEB-INF/view/로 옮김
	> 이를 통해 경로가 길어지고 페이지를 찾는 과정이 복잡해짐
* 복잡함을 해결하고 쉽게 찾을 수 있게 하는 ViewResolver를 사용해보자

* 뷰 페이지 설정은 setter를 이용했지만 오버로드 생성자를 이용해 객체 생성과 동시에 설정이 가능하다.
	> ModelAndView mv = new ModelAndView("/WEB-INF/view/index.jsp");

* /WEB-INF/view/... .jsp는 반복되며 계속 중복되므로 이것을 빼고 ModelAndView mv = new ModelAndView("index");만 남긴다.
	> 이렇게 반환하면 디스패처가 그런 리소스가 없다(JSP,경로가없음) 이것을 도와주는 것이 ViewResolver의 역할이다.
	> 반환하게 되면 이에 앞뒤에 경로와 파일확장자를 붙여 실질적인 view를 찾게 도와준다.

* dispatchar-servlet.xml 파일에서 뷰 리졸버 빈을 추가한다.
    <!-- ViewResolver 설정 -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <!-- 접두사 -->
        <property name="prefix" value="/WEB-INF/view/"/>
        <!-- 접미사 -->
        <property name="suffix" value=".jsp"/>
    </bean>




< ------------------------------------------------------------ HTML파일 설정하기 ------------------------------------------------------------ >
* 파일 다운로드 및 웹 루트로 옮김
* css미적용 및 이미지 로드 안됨 --> 왜?




< ------------------------------------------------------------ 정적파일 서비스하기 ------------------------------------------------------------ >
* images/logo.png파일이 존재 다만 실제로 경로를 열면 404에러 발생(localhost:8080/images/logo.png)
* 이유는 기본적으로 Spring은 정적인 파일을 제공하지 않도록 막아놓아서 발생함
* HTML, img등은 서비스 불가능하도록 막아놨지만 jsp는 열어놓음

* 위와같은 일이 발생하는 이유
	> web.xml에서 url-pattern이 /이다.
	> /* : jsp까지 막겠다는 의미
	> /  : 기본적인 정적인 파일은 막지만 jsp는 허용함
	> 따라서 정적(static)인파일(img, js, css 등)이 로드되는것을 막는다.

* 이를 위해 따로 리소스 설정을 해주어야 한다.
	<mvc:resources location="/resource/" mapping="/resource/**"
	> 위와같이 resource라는 폴더안에 static file들을 모아놓고 url을 리소스를 통해 제공할 수 있게 만듦

* 이것을 위해 schema, namespace 설정이 필요하다.
	> dispatcher-servlet.xml에서 리소스 설정이 mvc: 접두사를 이용해 설정한다.
	> 기본적으로 dispatcher-servlet.xml를 처리하는 처리기는 beans라 하는것을 처리한다.
	> 우리는 mvc를 담당하고 있는 다른 처리기가 필요하다.

* mvc처리기 이용하기
	> beans 태그에 설정을 추가한다.
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="...다른설정..."
		xmlns:mvc="http://www.springframework.org/schema/mvc"		<< 추가
		xsi:schemaLocation="...다른설정...
       		http://www.springframework.org/schema/mvc
        	https://www.springframework.org/schema/mvc/spring-mvc.xsd">	<< 추가

	> 이후 사용가능한 태그 목록을 보면 mvc접두사가 붙은 태그들도 이용할 수 있게된다.

* 설정들의 의미
	> 우리는 태그로 xml에서 어떤 명령어를 입력한다.

	> xsi:schemaLocation="http://www.springframework.org/schema/mvc
     			https://www.springframework.org/schema/mvc/spring-mvc.xsd" 페이지 내에서 쓸 수 있는 태그를 정의하는 파일 (스키마파일)
		> 그리고 그 안에 들어가는 url들이 스키마 파일 정의에 대한 이름들이 된다.
		> 이름이 긴 이유? : 다른 스키마 파일들도 같이 포함시키려면 중복되면 안된다. (클래스 만들때 패키지명 같이 사용하는것처럼) 따라서 도메인명 사용

	> xmlns:mvc="http://www.springframework.org/schema/mvc"
			스키마 파일의 원래 이름을 가지고 쓰긴 너무 길어서 이름을 대신해서 mvc라는 접두사를 이용한다.
			즉 xmlns:mvc="이곳엔 스키마를 입력한다." 그리고 mvc는 스키마를 식별하는 namespace가 된다.

	> 즉 mvc:를 붙여서 태그를 이용하면 스키마에 정의되어 있는 것을 사용하는 것이다.
	
* 우리는 여기서 mvc:resources 태그를 사용할 것이다.
	> <mvc:resources location="" mapping="" />
	> Spring dispatcher가 위 명령어를 읽으면 mvc설정을 따라서 맞게 행동함
	> mapping : 특별한 url을 사용자가 요청
	> location : 사용자가 요청한 url(mapping)은 여기에서 찾게됨(하위폴더 포함)

	> <mvc:resources location="/resource/" mapping="/resource/**" />

* 하지만 mapping을 /resource/**로 두었으므로 이미지를 불러오기 위해선 /images/...png 파일들의 경로를 /resource/images/...png로 변경해야함 >> 번거로움

	> <mvc:resources location="/static/" mapping="/**" />
	> 이미지가 루트에 있는것처럼 둔다.
	> 기존 html/ 폴더에 static 파일을 두고 webapp/에 static/이라는 이름으로 옮긴다.
	> 따라서 정적인 파일이 요청이 되면 모든 요청은 /static/이라는 폴더에서 뒤진다.
	> 실제로는 static이란 폴더안에 이미지 파일이 있지만 mapping을 /**로 두었으므로 static이 root가 되는것처럼 작용한다.

* 실제 경로 테스트 해보기
	> http://localhost:8080/static/images/banner3.svg	>> 404 오류 발생 (mapping을 /로 두었으므로)
	> http://localhost:8080/images/banner3.svg		>> 정상적으로 이미지 출력됨

	> 결국 /static/과 /** 매핑되었으므로 static/을 root로 생각한다. 따라서 모든 static 파일들은 static/파일아래에 둔다.




< ------------------------------------------------------------ 공지사항 컨트롤러 추가하기 ------------------------------------------------------------ >
* static/ 폴더의 구조를 그대로 view안에 notice/detail.jsp, notice/list.jsp 파일 생성 및 기존 html파일에서 내용 복사해서 가져오기
* 이에 맞는 컨트롤러도 생성 com.hoseok.web.controller.notice.ListController.java, DetailController.java

* Controller에서는 View, Model을 준비해서 DispatcherServlet 클래스로 넘겨주는데 일단 IndexController.java의 내용을 빌려쓴다.
	> 올바른 경로 작성하기 ViewResolver에서 접두사:/WEB-INF/view/, 접미사:.jsp이므로 제외하고 작성 ex) "notice/list"

* 이제 URL 매핑을 시켜줘야함 --> dispatcher-servlet.xml
	<bean id="/notice/list" class="com.hoseok.web.controller.notice.ListController"/>
	<bean id="/notice/detail" class="com.hoseok.web.controller.notice.DetailController"/>

* 이제 기존 xxx.html로 링크되어있던 하이퍼링크들을 컨트롤러에 매핑한 URL로 변경해준다.




< ------------------------------------------------------------ Detail 컨트롤러 추가와 View페이지 집중화의 필요성 ------------------------------------------------------------ >
* DetailController를 ListController와 동일하게 만들어주고 URL만 변경해준다.
* 다만 이후 dispatcher-servlet.xml에서 매핑을 해준다.

* 이렇게 만들고 notice/detail까지 들어가게 되면 이곳에서 header의 url들이 모두 list.html로 매핑되어있는것을 알 수 있다.
	> 그렇다면 header의 어떤 내용을 수정하기 위해서 모든 페이지를 일일이 변경해야할까? --> 비 효율적
	> 따라서 View 페이지의 집중화가 필요해짐




< ------------------------------------------------------------ 페이지 공통분모 집중화 ------------------------------------------------------------ >
* 지난시간 detail, list, index페이지에서 공통으로 나타나는 페이지의 일부분을 볼 수 있다.
	> 페이지를 어떻게 나누고 집중화 할 수 있을지 알아보자
	> 기존 페이지들은 공통 부분을 수정하게 되면 모든 페이지를 다 수정해야만 한다.
	> page구조에서 어떤 Content를 가지는 내용은 링크를타고 맨 끝에 있는 페이지에 일반적으로 존재함
	> 또한 끝 페이지는 목록, 자세한페이지, 수정 등 페이지가 왔다갔다 한다.
		> 페이지를 라우팅하기 위한 링크들은 페이지 내부에 존재 따라서 목록에서 클릭-> 자세한페이지 수정클릭-> 수정페이지
	> 그리고 이와 유사한 컨텐츠들은 좌측 메뉴에 묶여서 존재하고 클릭시 유사한 페이지들이 왔다갔다함
	> 층을 올라갈수록 하위페이지들을 찾아가기위한 링크들이 존재하고 위로 올라가는 내용들은 하위페이지의 요약본, 노출할것, 분석된 데이터들을 보여줌
	> 결국 최상위의 페이지는 전체 사이트에 대한 링크들을 가짐

* 다만 모든 페이지마다 공통으로 가지는 영역들이 존재함 (header, footer), 일정영역에서 동일한 aside 등이 있다.

* 따라서 공통 부분을 분리하여 기존 페이지들이 공통으로 참조하도록 한다.
	> JSP는 공통분모를 분리해서 다른폴더에 두고 어떤 페이지에서 쓰겠다 하면 jsp:include를 이용해 외부페이지를 링크해 쓸 수 있는 방법제공 하지만 사용하진 않을것

* jsp:include의 문제점 
	> 한 페이지가 다른곳에서 3개의 jsp:include를 참고하게 된다.
	> 하지만 각각의 jsp:include들은 여러페이지에서 사용되므로 페이지마다 include하는것들이 중복되어 나타난다.
	> 따라서 페이지를 만들때마다 include를 해줘야하는 부분이 불편해짐 --> 이것도 집중화 할 수 있는 방법이 있을까?

* Tiles 라이브러리
	> include하는 내용마저도 layout 이라는 이름으로 따로 만들고 페이지 추가시 main 부분에 해당되는것만 만들게 된다.

* 실제로 만든 페이지의 header, footer, aside, 그리고 content에 해당되는 main과 layout을 나눠보자





< ------------------------------------------------------------ 페이지 모듈 분리하기 ------------------------------------------------------------ >
* 페이지 집중화를 위해 페이지에서 공통으로 나타나는 부분과 그렇지 않은부분을 나눠보자

* index.jsp의 공통부분 분리하기
	> view/inc/header.jsp, footer.jsp 생성하고 index.jsp에서 header와 footer부분을 각각의 jsp파일로 옮긴다.

* list.jsp의 header, footer부분은 동일하므로 지우기

* list.jsp, detail.jsp의 공통부분이 존재 aside, visual영역이 공통분모 이므로 빼서 공통적으로 관리한다(customer/inc/)
	> view/inc/안에는 view 전체에서 사용되는 부분이고
	> list와 detail의 공통부분은 공지사항, 자주하는질문, 수강문의, 이벤트들에서 같이 사용되는 메뉴이므로 다른폴더에 생성하는것이 바람직함
	> 고객센터 관련 내용이므로 customer/inc/폴더에 생성한다.

* 그리고 notice/ 폴더도 고객이 사용하는 메뉴이므로 customer/ 에 묶인다. 
  따라서 옮겨서 같이 담는것이 페이지 관리가 바람직해짐 이곳에 공지사항, 자주하는질문, 수강문의, 이벤트등의 폴더들도 생성해서 같이 관리함

* 결국 list, detail.jsp는 main과 main을 포함하는 껍데기들만 남아있다.
	> 껍데기들은 aside, visual, header, footer를 배치할 수 있는 영역 --> layout
	> 그리고 나머지는 main 페이지
	> 결국 list, detail.jsp는 총 2개의 페이지가 남아있다. : main, layout

* 마지막으로 main도 분리하고 남아있는 정보(layout)도 하나의 페이지가 될 것이다.
	> view/customer/inc에 list.jsp를 복사하고 layout.jsp로 이름을 변경하고 레이아웃의 역할만 남긴다.(main부분을 잘라냄)
	> 그리고 기존의 list.jsp의 내용을 지우고 잘라낸 main 내용만 붙인다.
* 이렇게 list.jsp는 main내용만 남아있고 나머지 공통적인 부분들이 정리되고 모듈화가 됨

* 이걸 합치기 위해서 Tiles 라이브러리를 설정해야 한다.





< ------------------------------------------------------------ Tiles 지시서 작성하기 ------------------------------------------------------------ >
* 페이지에서 나타내는 공통부분을 쪼개서 inc/ 폴더에 담아둠
* Tiles를 이용하기 위한 지시서를 작성하는 법에대해 알아보자!

* MVC Model2
	> /notice/list (사용자 요청 오면) -> Controller는 View를 찾기위해 notice/list 문자열 반환 -> ViewResolver가 prefix, suffix문자열 붙임
	  -> 접두,접미사를 붙인 형태의 리소스를 찾아서 결과를 사용자에게 반환함

* 이 때 Controller가 반환하는 형태 하나 더 생김 -> notice.list
	> "WEB-INF/view/notice/list.jsp"는 실제로 페이지를 찾기위한 파일명을 반환한것
	> 또 다른 형태인 notice.list형태로 값을 반환하면 이를 가지고 Tiles를 호출함

* Tiles가 notice.list형태를 받으면 형태에 맞는 page조각들을 조합해서 반환하게 됨
	> 어떤 페이지들이 어떻게 결합되어야 하는지는 Tiles에게 지시해야함
	> 그렇게 되면 Tiles가 지시대로 페이지를 결합시켜서 돌려주게 된다.

* Controller가 notice.list, notice/list 둘 중에 하나를 반환한다 그걸 어떻게 알까?
	> 우선순위가 존재하므로 notice.list의 우선순위를 높임
	> 초기에는 notice.list형태로 반환해서 먼저 Tiles지시서를 뒤져보고 없으면 notice/list를 찾음 (그래도 없게되면 오류발생)

* notice.list에 대한 지시서를 작성할 때 두 가지의 지시사항이 필요
	1. 특정 이름으로 반환을 받으면 그것을 어떤 조합으로 붙일지 지시 필요
	2. 페이지를 붙일경우에 layout에서 어떤 위치에 붙일지 위치를 정하는 지시 필요(layout에서 페이지를 어떤식으로 붙일것인지)

* https://tiles.apache.org/에 접속해 라이브러리를 다운받음
	> https://tiles.apache.org/framework/tutorial/basic/pages.html 에서 xml 형식을 가져옴 주로 /WEB-INF/tiles.xml로 저장함
[tiles.xml]
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tiles-definitions PUBLIC
       "-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN"
       "http://tiles.apache.org/dtds/tiles-config_3_0.dtd">
<tiles-definitions>
	<definition name="notice.list" template="/layouts/classic.jsp">
		<put-attribute name="title" value="Tiles tutorial homepage" />
		<put-attribute name="header" value="/tiles/banner.jsp" />
		<put-attribute name="menu" value="/tiles/common_menu.jsp" />
		<put-attribute name="body" value="/tiles/home_body.jsp" />
		<put-attribute name="footer" value="/tiles/credits.jsp" />
	</definition>
</tiles-definitions>

* 위의 설정에서 definition태그의 name속성은 Controller가 반환하게 될 이름이다.
* 따라서 Controller에서는 View, Model을 준비해서 DispatcherServlet 클래스로 넘겨주는데 이때의 값을 notice/list 에서 notice.list로 변경한다.
	> 꼭 .이 아니라 다른 방식을 사용해도 되지만 . 문자가 패턴만들기가 간편하다

* 그렇다면 detail.jsp페이지도 또 definition을 추가해야하나?
	> 하나로 합칠 수 있는 방법이 있다.

* tiles.xml에서 notice.list라는 이름을 받게 되면 나눠졌던 페이지들을 합치기 위한 페이지를 담게된다.
	> template속성에 어떤 layout을 사용할지 설정한다. (web root를 기반으로 설정)
	> layout에 붙이기 위해 조각난 페이지들을 put-attribute태그에 붙이게 된다.

* put-attribute 태그 속성
	> name : 사용자가 정하는 이름(layout의 어떤 부분인지)
	> value : 실제 View파일의 경로(web root를 기반으로 설정)

* 최종 xml (각 controller의 DispatcherServlet Class에 전달하는 값은 definition태그의 name속성과 동일해야 한다.)
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE tiles-definitions PUBLIC
           "-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN"
           "http://tiles.apache.org/dtds/tiles-config_3_0.dtd">
    <tiles-definitions>
        <definition name="notice.list" template="/WEB-INF/view/customer/inc/layout.jsp">
            <put-attribute name="title" value="Tiles tutorial homepage" />
            <put-attribute name="header" value="/WEB-INF/view/inc/header.jsp" />
            <put-attribute name="visual" value="/WEB-INF/view/customer/inc/visual.jsp" />
            <put-attribute name="aside" value="/WEB-INF/view/customer/inc/aside.jsp" />
            <put-attribute name="body" value="/WEB-INF/view/customer/notice/list.jsp" />
            <put-attribute name="footer" value="/WEB-INF/view/inc/footer.jsp" />
        </definition>
        <definition name="notice.detail" template="/WEB-INF/view/customer/inc/layout.jsp">
            <put-attribute name="title" value="Tiles tutorial homepage" />
            <put-attribute name="header" value="/WEB-INF/view/inc/header.jsp" />
            <put-attribute name="visual" value="/WEB-INF/view/customer/inc/visual.jsp" />
            <put-attribute name="aside" value="/WEB-INF/view/customer/inc/aside.jsp" />
            <put-attribute name="body" value="/WEB-INF/view/customer/notice/detail.jsp" />
            <put-attribute name="footer" value="/WEB-INF/view/inc/footer.jsp" />
        </definition>
    </tiles-definitions>


* 지시서는 완성되었지만 layout에서 각각의 조각들을 어떻게 어느위치에 붙일것인지 설정해야함





< ------------------------------------------------------------ layout 페이지 만들기 및 Tiles 라이브러리 설정 ------------------------------------------------------------ >
* Tiles가 사용하게 될 지시서는 작성
	> notice.list와 같이 Tiles가 지시받는 목록중에 있는 이름을 받음 이 때 두가지의 지시서 필요
		1. notice.list를 가지고 만들어낼 조각들의 명단 필요 --> tiles.xml(어떤 페이지들이 필요한가에 대한 목록)
		2. page들을 layout의 어디에다 포함시킬지 지시서 필요

* Tiles 제공 태그 라이브러리
	> Maven project이므로 pom.xml로 받아옴(Global Repo로 검색)
	> tiles.jsp 추가

* layout.jsp에 태그라이브러리 추가
	<%@ taglib prefix="tiles" uri="http://tiles.apache.org/tags-tiles" %>

* layout에 각 위치에 맞는 조각들(page) 세팅
	> <tiles:insertAttribute name="header" /> 태그 이용
	> name은 tiles.xml에서 put-attribute(속성을) layout에 그 속성을 insert하겠다는 의미

* tiles.xml put-attribute의 name중 title을 페이지가 아니라 문자열이다.
	> <tiles:getAsString name="title"/> 형식으로 문자열을 꽂을 수 있다.

* 한 가지의 설정을 더 해야 실행할 수 있다.





< ------------------------------------------------------------ Tiles ViewResolver 설정하기 ------------------------------------------------------------ >
* Tiles를 이용하기 위해 페이지 명단과 어디에 포함시킬지에 대한 지시서 완성 하지만, 한 가지 설정이 더 남음

* 사용자가 URL 요청 -> Controller가 URL(/notice/list)을 받음 -> 데이터베이스를 이용해 데이터생성(미구현) -> 그것을 출력하기 위한 페이지 요청
  -> 이때 jsp페이지가 아닌 tiles를 이용

	> jsp를 요청할 때는 Controller가 반환하는 문자열을 이용해 페이지를 찾아주는 작업을 함 --> 이 때 리소스를 찾기위해 접두사, 접미사를 붙임

* 이번에는 notice.list를 반환하게 되면 이것으로 페이지를 합치는 작업을 함 이 때 tiles를 요청하고 페이지를 만들어내는 과정이 있다.
  notice.list에 해당되는 페이지를 찾아주는 역할을 하는 것이 있어야함
	> 지금까지는 페이지명단과 어디에 포함시킬지에 대한 내용은 완성했지만, notice.list를 가지고 page를 이어주는 tiles ViewResolver가 있어야함
	> 즉 반환되는것을(notice.list) tiles.xml 페이지 명단을 찾아서 연결해야함 --> 지시서가 어디있는지 알아야함

* 즉 기존의 InternalResourceViewResolver 말고 다른 View Resolver가 필요하다
    <!-- Tiles ViewResolver 설정 -->
    <bean class="org.springframework.web.servlet.view.UrlBasedViewResolver">
        <property name="viewClass" value="org.springframework.web.servlet.view.tiles3.TilesView" />
        <property name="order" value="1" />
    </bean>
    
    <bean class="org.springframework.web.servlet.view.tiles3.TilesConfigurer">
        <property name="definitions" value="/WEB-INF/tiles.xml"/>
    </bean>

	> TilesConfigurer가 아파치 타일즈로 타일 정의를 불러오고 배치함
	> UrlBasedViewResolver는 view를 설정하는데 내부적으로 serViewClass로 TilesView를 세팅하고 setOrder로 첫번째로 tiles.xml을 뒤져본다
	  tiles.xml에 반환된 값(ex:notice.list)과 일치하는것이 존재하면 페이지 조각을 조립하고 화면에 출력한다.
	  만약 존재하지 않으면(notice/list) 후에 InternalResourceViewResolver에서 직접적으로 View페이지를 찾게된다. (prefix, suffix붙여서)

* 따라서 기존에 만들었던 InternalResourceViewResolver도 order를 2로 setting 해줘야 함
    <!-- ViewResolver 설정 -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <!-- 접두사 -->
        <property name="prefix" value="/WEB-INF/view/" />
        <!-- 접미사 -->
        <property name="suffix" value=".jsp" />
        <property name="order" value="2" />
    </bean>

* 일단 실행하게 되면 jstl 라이브러리가 없으므로 오류가 발생 따라서 pom.xml에서 javax.servlet jstl 라이브러리를 추가해야함

* 아직 index.jsp는 적용하지 않았으므로 직접 notice/list url을 요청하면 view 페이지들이 정상적으로 합쳐진걸 볼 수 있다.





< ------------------------------------------------------------ Tiles 설정에 Wildcard 이용하기 ------------------------------------------------------------ >
* Tiles 설정에서 페이지들을 추가할 때 마다 definition을 계속 만들어야 하는 비효율적인 작업을 보임

* notice.list와 notice.detail은 페이지 이름만 다를뿐 나머지 조합하는 페이지는 동일
* Tiles 라이브러리는 이러한것을 도와주기 위한 패턴 문자인 Wildcard를 제공해준다.

* definition태그에서 notice.list혹은 notice.detail로 페이지의 부분이 달라진다 따라서 notice.*과 같이 변동되는 부분을 *로 둔다 이는 2개 이상 사용 될 수 있다.
	> ex) notice.*.*
* definition 태그 내부에서 *의 개수에 따라 번호가 순차적으로 부과 된다. 따라서 {1}, {2}와 같이 사용 가능하다
* 또한 Wildcard로 정규식도 사용 가능하다
* 위와 같은 Wildcard의 사용법은 https://tiles.apache.org/framework/tutorial/advanced/wildcard.html에 가보면 자세히 볼 수 있다.

<tiles-definitions>
    <definition name="notice.*" template="/WEB-INF/view/customer/inc/layout.jsp">
        <put-attribute name="title" value="공지사항목록" />
        <put-attribute name="header" value="/WEB-INF/view/inc/header.jsp" />
        <put-attribute name="visual" value="/WEB-INF/view/customer/inc/visual.jsp" />
        <put-attribute name="aside" value="/WEB-INF/view/customer/inc/aside.jsp" />
        <put-attribute name="body" value="/WEB-INF/view/customer/notice/{1}.jsp" />		>> 상단의 *의 값을 이용하기 위한 표현식 1개밖에 없으므로 {1}로 표기
        <put-attribute name="footer" value="/WEB-INF/view/inc/footer.jsp" />
    </definition>
</tiles-definitions>

* 위와같이 Wildcard를 사용 가능하다.





< ------------------------------------------------------------ Root 페이지들을 위한 Layout 페이지 만들기 ------------------------------------------------------------ >
* Index page에서 header와 footer가 없음 --> root 페이지들은 Tiles 설정을 어떻게 할까?
* index를 위한 layout을 만들어야함
* root에 있는 페이지들만 사용하는 layout 필요  /WEB-INF/view/inc/layout.jsp 생성하고 기존의 index.jsp에서 body 영역을 지운 파일을 이용한다.
* 어떻게 조합할지 구성하고 tiles.xml도 추가해준다.
	> 이때 name을 *을 주게되면 "모든파일"이 해당되므로 뒤에있는 notice.*에 기회가 가지 않음 --> 주의 해야함
* 그렇다면 두번째로 내려야 하나?
	> 자칫하면 *을 찾는 과정에서 무한루프에 빠질 수 있다.
* 결국 root라는 폴더에 담고 root.*을 이용하는것이 바람직함
	> 다만 실제 폴더를 생성하는것이 아닌 형식적인 의미로 사용
	> IndexController에서 반환하는 값을 root.index로 변경해야함

* 실행하면 정상적으로 동작

* Tiles 라이브러리 기능 및 설정 방법을 알아봄

* Spring MVC에서 제공하는 기능을 알아보자
	> 주로 FrontController기능을 제공해준다. FrontController는 출력과 입력을 담당함
	> 지금까지 입력을 다루지 않았다 따라서 어떻게 다룰 수 있는지 알아보자













