< ------------------------------------------------------------ Spring MVC ------------------------------------------------------------ >

* Spring을 사용하지 않고 Tomcat(Tomcat Configuration)을 이용해 웹개발 가능(Servlet, JSP)
	> 이때는 web.xml을 사용 : 사용할 라이브러리 인스턴스화(Mybatis, Tiles) 등등의 설정
	> Spring을 사용하겠다 하면 이곳에 Spring을 얹음(Spring Dispatcher) : Spring Web 개발시 Spring Dispatcher 라이브러리를 기반으로 사용

* Spring Dispatcher
	> Controller의 공통분모를 모아놓은 Front Controller를 Spring에서 제공해줌 : 그게 Spring MVC다.
	> Spring MVC를 쓰겠다면 Spring이 거의 모든것을 커버함 -> Spring을 쓰기위한 또다른 설정이 필요함 : Spring Configuration

* Spring Web : Spring Configuration이 늘어남
	> 톰캣의 web.xml 설정에서 옮겨짐 : Spring Config가 라이브러리 기타 등등을 관리하게 됨 (Mybatis, Tiles등)
	> 또한 Spring Configuration에는 일반적으로 자신만의 설정인 Servlet, Service, Security설정들이 더 추가 됨

* 결국 톰캣, 톰캣설정, 스프링, 스프링 설정 하는 방법들을 알아야함
	> Spring 버전이 변화하며 설정방법도 변화하기 시작함
		> XML, Annotation, Java등 다양한 방법 존재

* 최근에는 이러한 설정에 대한것들을 도와줄 수 있는 Spring Boot가 나옴
	> Spring MVC를 대신하기보단 설정에 대한것들을 모아서 편하게 해줄 수 있는 부가적인 프레임워크

* Spring에 Spring Boot를 얹어서 사용하게 되면 기존의 복잡한 설정을 피할수 있게 된다.
	> Stater Configuration을 필요로하는 각각의 설정들을 한번에 묶어서 라이브러리로 가지고 있다 -> 설정에 대한 라이브러리를 일일이 설정할 필요가 없다.
	> 최대한 설정을 줄이고 설정파일 하나만 둠 applicaiton.properties(단순 텍스트파일) 혹은 YAML(Json같은 형태의 표기법파일)의 설정파일 중 골라서 사용함 (주로 application.properties사용)

* Spring Boot를 사용하게 되면 결국 설정에 대한 부분이 크게 줄어든다.





< ------------------------------------------------------------ Spring MVC란 ------------------------------------------------------------ >
* Spring을 이용해서 웹 개발을 해보자

* 기존 MVC model2 방식
	> Controller : servlet, View : jsp 로 나눔 forwarding을 dispatcher를 이용해 구현함
	> 하지만 위와같이 되며 모든 Controller는 Dispatcher를 가지게 됨 --> 비효율적

* 기존 MVC model2 방식의 변화 : Dispatcher를 집중화 한 후의 모델
	> 순수하게 Controller의 기능만 구현시킴 --> 이것은 Servlet이 아니라 일반적인 자바 클래스(POJO:Plain Old Java Object)로 구현함
	> 기존 Controller로 이용하던 Servlet은 dispatcher기능만 남아있다 --> 이는 forwarding하는 기능이므로 거의 기능이 똑같음 --> 하나만 남김(디스패처의 집중화)
	> 사용자의 요청을 컨트롤러에 전달하고 요청한 결과물을 받아서 다시 view에게 전달함 (중간매개의 역할) 매우 중요한 역할

* dispatcher의 역할 
	> 사용자의 요청을 받는다는것의 의미 : 단순 요청 라우팅이아니라 사용자 입력을 쉽게 컨트롤러로 전달해줌
	> 그렇게되면 dispatcher는 servlet api를 이용해 파라미터를 받아오는 등의 서블릿의 기능을 차단해주는 역할
	> Controller에 기본적 사용할 수 있는 String, int등으로 전달해줌 혹은 객체화된 데이터로 담아서 줄 수 도있다.
	> 결국 Controller에선 Servlet 라이브러리를 하나도 사용하지 않고도 입력을 처리하게 되거나,
	  Controller가 데이터를 마련해 view로 전달하려 해도 dispatcher기능이 없으므로 디스패처가 컨트롤러에게 요청을 다시 돌려받게 되는데
	  그 때 Controller에서 어떤 view 페이지가 필요하다는 view페이지 정보만 알려주면 디스패처가 view페이지를 호출하게됨 따라서 서블릿 기능을 dispatcher로 한정한다.
	> 이게 바로 dispatcher를 따로 분리하는 이유

* 따라서 dispatcher는 서블릿, 톰캣, was라고 하는것과 Controller와 결합력을 낮추게 하며 컨트롤러를 혹시 다른 환경에서도 쓸수있게 할수있다.

* 결국 front controller(dispatcher)를 만드는것이 중요하며 만드는 것을 Spring이 제공함
	> Spring이 제공하는 front controller 라이브러리를 이용해 Controller를 만듦
	> front controller를 잘 만들게 되면 톰캣과 이별 할 수 도있게 웹개발 할 수 있다.

* Dispatcher역할을 가지고 있는 Dispatcher servlet(Spring 제공하는 기능)에 여러 URL이 옴
	> 모든 URL을 받아서 처리해야 한다.
	> 모든 URL요청이 오게됨 --> 그것을 적절히 알맞은 Controller에게 배분해야함 --> URL에 대한 정보를 어떤 Controller가 처리할지 가지고 있어야한다.
	> 따라서 Spring이 제공하는 Dispatcher 관련된 front controller 라이브러리 사용시 설정파일이 필요하다.
		> 과거엔 url매핑, 어노테이션으로 설정했으나 그 내용이 *-servlet.xml로 옮겨진다.
		> 즉 web.xml은 모든 url이 dispatcher servlet로 향하게 함,
		  이것을 알맞은 Controller에게 배분하기 위해 dispatcher servlet 설정파일에서 매핑 정보를 쓰게된다(*-servlet.xml)
	> 어떻게 보면 톰캣의 매핑정보가 스프링위로 올라간것 뿐으로 보인다. 하지만 결합력을 낮추는 부분에서 장점이 있음

여담 : 과거에는 Dispatcher Servlet을 직접 만듦 --> 요즘은 Spring것을 사용 --> Spring에 종속되는 문제 야기
	> 방법론으로 발전시켜나가는게 바람직해보임 --> 가능하면 개별적으로 만들어가며 실력을 키우는것도 좋아보입니다.

* Controller는 반환할 때 model, view의 정보를 전달함 --> dispatcher가 요청시 반환받은 두 개의 값을 가지고 view를 찾아서 관련된 데이터(Model)을 전달함
	> 즉 Spring MVC는 dispatcher servlet 라이브러리를 사용하는 것이다.





< ------------------------------------------------------------ 실습환경 준비하기 ------------------------------------------------------------ >
* spring.io에 Spring Tools 4 for Eclipse를 다운받는다.
* apache 9 다운로드 (Spring Boot는 내장 톰캣이 존재해서 따로 다운받을 필요 없음)

* 이후 다운받은 Spring Tools 4 for Eclipse를 압축풀고 내부에 contents 알집을 압축을 푼다
	> sts-4.13.0.RELEASE를 잘라내서 tools 파일로 옮김

* 이후 SpringToolSuite4.exe파일을 실행한다.




< ------------------------------------------------------------ 메이븐을 이용한 기본 웹 프로젝트 생성하기 ------------------------------------------------------------ >
* Create new Spring Starter Project == Spring Boot 이용
* 우리는 legacy Spring 이용 웹 프로젝트를 Maven 기반으로 생성해야함 --> Java EE 툴 설치

* 메이븐 프로젝트 생성
	> Group id : com.hoseok
	> Artifact id : webPrj
	> Packaging : war

* pom.xml에 web.xml이 없다는 오류가 발생하므로 apache tomcat에 ROOT/WEB-INF 폴더에서 web.xml을 가져옴
	> 추가로 오류 발생시 --> maven-war-plugin을 3버전 이상으로 임의로 플러그인 추가해줌

* JDK 버전 올리기
	> 1. pom.xml -> overview -> Properties : name=maven.compiler.source, value=1.8 추가 그리고 name=maven.compiler.target, value=1.8로 등록함 이후 update project

* JSP 파일 추가시 오류 발생
	> pom.xml에 tomcat api 추가 해줘야함 구글에 tomcat-api 검색해서 맞는 버전의 dependency 코드 긁어오기
	> 혹은 pom.xml하단에 dependencies -> add 이후 검색해서 추가하기도 가능 (Global Repository rebuild작업해야 검색가능)

* 이후 실행하고 tomcat 홈 디렉토리 등록하고 실행하면 실행된다.

* 이제 MVC 방식으로 변경해야한다




< ------------------------------------------------------------ Dispatcher Servlet 라이브러리 설정하기 ------------------------------------------------------------ >
* Spring Dispatcher를 Front 컨트롤러로 설정해야함.

* 기존에 컨트롤러와 디스패처를 같이 사용했지만 이것을 분리해 디스패처에 서블릿관련 코드를 두고 컨트롤러는 POJO 클래스로 만들기로 함

* 디스패처 서블릿은 DispatcherServlet.class를 이용한다. 이것을 다운로드 받아야함
	> 이전에 구글 tomcat api를 받아온것은 Global Repo -> Local Repo로 받아온것이다.
	> 따라서 직접 Global Repo에서 받아올 수 있다. 다만 Rebuild Index로 업데이트 이후 검색해서 사용가능(pom.xml:Dependencies -> Add -> 검색
		> 이렇게 되면 검색한것을 원격에서 가져와서 로컬로 저장함

	> 두번째로 tomcat api 검색후 Spring web MVC 검색해서 복사해서 dependency 입력


* Maven Dependencies : Local Repo에 있는 내용중 참조하고 있는 라이브러리 목록을 보여줌
	> 여기서 Spring-webmvc -> org.springframework.web.servlet -> DispatcherServlet.class를 우클릭후 Copy Qualified Name 클릭
	> 이렇게하면 패키지명과 클래스명을 한번에 받아올 수 있다.

* 위에서 복사한 내용(front controller 역할을 하는 서블릿 클래스)을 web.xml에서 설정한다.




< ------------------------------------------------------------ dispatcher-servlet.xml 파일 설정 ------------------------------------------------------------ >
* 기존에 MVC 구현하는 방식
	> View(JSP), Controller(extends HttpServlet)
	> view에 controller로 받아온 Model을 심음


* 하지만 SpringMVC에선 컨트롤러에서 서블릿을 이용하지 않을것이다.
	> Controller : POJO
	> Dispatcher : 이미 만들어져 있음(DispatcherServlet.class)

	> 따라서 지금껏 Servlet 프로그래밍을 할 땐 URL 매핑으로 Annotation을 사용했으나
	  DispatcherServlet.class는 남이 만든 서블릿을 설정하는 것이므고 소스를 가지고 있지 않으므로 XML을 이용해 설정할 수 밖에 없다.

* Dispatcher에 URL매핑을 할때는 web.xml에 하게된다. URL 매핑하기
	> Spring-webmvc -> org.springframework.web.servlet -> DispatcherServlet.class를 우클릭후 Copy Qualified Name 클릭
	> 이후 모든 URL을 Front Controller로 받기 위한 Servlet Mapping을 설정한다.
		<!-- mapping 정보를 넣음 -->
		<servlet>
		   <!-- mapping 주소가 서블릿과 연관을 맺기 위해 이름을 정해줘야 한다. -->
		   <servlet-name>dispatcher</servlet-name>
		   <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		</servlet>
	
		<!--
    	   	 front controller이므로 모든 URL을 만나면 위의 DispatcherServlet 클래스를 실행 
    	   	 이후 어떤 URL은 어떤 POJO클래스가 맞는지 분배하는 동작을 함 
   		 -->
		<servlet-mapping>
		   <servlet-name>dispatcher</servlet-name>
		   <!-- /이렇게만 작성하면 모든 URL이 통과되지만 /*로 작성하면 예외없이 모든 URL을 front controller가 받음 -->      
		   <url-pattern>/*</url-pattern>        
		</servlet-mapping>

	> 다음으로 아무 jsp파일을 실행하면 오류가 발생 
		IOException parsing XML document from ServletContext resource [/WEB-INF/dispatcher-servlet.xml]; 
		nested exception is java.io.FileNotFoundException: Could not open ServletContext resource [/WEB-INF/dispatcher-servlet.xml]

	> 우리는 현재 Dispatcher를 이용하려고 함 (모든 URL에 대해 요청을 받겠다.)
	> 현재 index.jsp를 요청했을때 어떤 URL이든 dispatcher가 받았다. 이후 dispatcher가 적절한 URL에 맞는 리소스를 배포해야 한다.
	> 하지만 그런 매핑 정보 즉 dispatcher가 어떤 페이지를 열것인지에 대한 정보는 *-servlet.xml 파일이 가지고있다.
	> 그리고 파일이 매핑정보를 가지고 있어야 오류가 나지 않음 따라서 /WEB-INF/*-servlet.xml을 생성하고 매핑을 설정해야함(원하면 설정으로 다른위치로 변경 가능)
 
	> 정리하면 모든 URL을 front controller로 받아왔으나 이후 어떤 POJO 클래스에 뿌려질건지에 대한 URL 매핑정보가 없어서 발생한다.
	> 이는 /WEB-INF/dispatcher-servlet.xml에 저장되어있고 우리가 servlet-name을 어떤걸로 정하느냐에 따라 xml파일 이름이 결정된다.(주로 dispatcher이용)


* 매핑 정보는 어떻게 넣을까?




< ------------------------------------------------------------ 스프링 컨트롤러 IndexController 작성하기 ------------------------------------------------------------ >
* Spring이 제공하는 MVC 지원 라이브러리(dispatcher lib)의 설정파일인 dispatcher-servlet.xml파일 작성하고 Index Controller 만들기
* 어떤 구문으로 만들어야 하는지 우리는 알 수 없다.
	> 이것을 제공해주는 Spring의 공식문서에서 레퍼런스 참조하기
	  https://docs.spring.io/spring-framework/docs/ 이곳에서 맞는 버전의 공식문서를 살펴봄 (core 목록 누르면 DI를 공부할 때 봤던 xml설정내용 보임)

* 기존의 Spring은 beans태그 안에서 bean태그를 이용해 설정해 어떤 클래스를 설정하면 이를 객체화해서(id=변수명, class=어떤클래스) IoC Container에 담게된다.
* 하지만 MVC에서 *-servlet.xml 설정파일은 id값이 변수명이 아니라 URL로 사용된다. 
  (컨테이너 담겨있는 객체들 중에서 사용자 요청이 URL로 옴, 그 URL을 가지고 IoC Container에서 꺼냄 무엇을? class속성에 있는 클래스로 된 객체를)

	<bean id="/index" class="com.hoseok.web.controller.IndexController">
		<!-- collaborators and configuration for this bean go here -->
	</bean>

* 이제 남은것은 Spring의 Dispatcher 클래스가 IndexController에서 컨테이너에서 꺼내고 가지고 있는 기능을 호출해야함
	> URL과 Controller를 매핑하는 정보를 id를 이용해 URL을 쓰는데 이게 bean 형태로 컨테이너에 담겨있음
	> 문제는 frontController에서 Controller를 사용하기 위해서는 요청을 수반할 수 있는 약속된 무엇 즉 기능이 있어야함
	> 약속된 함수명을 사용해야 한다. : handleRequest

* 모든 컨트롤러는 디스패처가 정의해놓은 함수를 사용해야 함, Controller interface 타입
	> POJO클래스가 이전에는 Servlet에 종속되어 있었지만 이제는 Dispatcher-Servlet에 종속되어 있다.

	public class IndexController implements Controller {

   		@Override
   		public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
   	     		// TODO Auto-generated method stub
   	    		return null;
  	  	}

	}

* 위에 Dispatch기능은 빠져있다(Spring이 제공) 따라서 함수가 반환하는 값은 Dispatch를 하기위한 ModelAndView를 반환한다.
	> ModelAndView객체를 생성해 어떤 모델을 전달하고 어떤 view에 전달할지 값을 설정하고 ModelAndview객체를 반환한다.
	public class IndexController implements Controller {

	    @Override
	    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        
        	ModelAndView mv = new ModelAndView();
        
        	// data키워드를 가진 String data를 담음 -> Model을 data란 이름으로 담아서 저장
        	mv.addObject("data", "Hello Spring MVC~");
        	// view에 대한 정보를 담음, 두가지 방법이 있다.
            	// 1. view 객체를 따로 만들어서 설정 : mv.setView(View view);
            	// 2. view의 이름만 담아서 설정 : mv.setViewName(@Nullable String viewName);
        	mv.setViewName("index.jsp");
        
        	return mv;
    	   }

	}

* model을 반환하고 나서의 실행 순서
	1. Model and View를 Dispatcher-Servlet으로 반환
	2. Dispatcher-Serlvet이 view로 Forwarding을 해 Model전달
	3. View는 출력할때 model을 사용해 사용자에게 보여줌

* 실제 IndexController를 실행하면 404오류 발생, 왜 그럴까?
	> tomcat을 이용해 tomcat Annotation을 사용할땐 매핑주소를 잘 써주지만 POJO클래스이므로(톰캣이 모름) 주소를 소스코드를 반환해버림
* 그래서 http://localhost:8080/webPrj/index로 직접 입력해 접속해도 404오류 발생 왜?
	1. IndexController를 실행하고 url에 http://localhost:8080/webPrj/index를 실행
	2. web.xml에 설정한대로 Front-Controller가 모든 URL을 받고 약속된 *-servlet.xml에서 어떤 컨트롤러를 실행할지 찾음 따라서 IndexController실행함
	3. IndexController에서 view이름을 설정하고나서 mv.setViewName("index.jsp"); 이후 포워딩하게되는 부분도 결국 하나의 요청임
	4. DispatcherServlet에선 이를 다시 받아서 *-servlet.xml로 보냄
	5. 하지만 inde.jsp로 지정된 url이 없으므로 404 오류 발생

* 여기서 기존의 web.xml설정이 위와같은 문제를 야기함
	<servlet-mapping>
	   <servlet-name>dispatcher</servlet-name>
	   <!-- /이렇게만 작성하면 모든 URL이 통과되지만 /*로 작성하면 예외없이 모든 URL을 front controller가 받음 -->      
	   <url-pattern>/*</url-pattern>
	</servlet-mapping>
	
	> url-pattern에서 /* 별표까지 쓰게 되면 어떠한 요청(forwarding이든 get요청이든)도 무조건 dispatcher를 거쳐서 지나감.
	> 결국 index.jsp를 포워딩하는 부분에서 다시 DispatcherServlet로 전달되고 *-servlet.xml 파일에서 url-mapping을 찾으므로 404오류가 발생한다.

* 결국 url-pattern에서 /* -> /로 변경
	> 이렇게 하면 DispatcherServlet을 거쳐서 dispatcher-servlet.xml에서 매핑정보를 찾지만
	> dispatcher-servlet.xml에서 리소스 정보를 찾지만 없게되면 그냥 리소스를 직접 요청함

* 이후 실행하고 URL을 요청하면 정상적으로 페이지 출력
* 하지만 *를 지우게 되면서 발생되는 문제점이 존재한다.




< ------------------------------------------------------------ View 페이지를 위한 위치 ------------------------------------------------------------ >
* url-pattern에서 /* -> /로 변경하게 되면 문제점이 발생함
	> 일단 Controller와 View가 있다. 하지만 이를 실제 Application에서 보면 하나로 생각한다.
	> 즉 사용자 요청이 왔을때 따로 요청이 오는것이 아닌 무조건 Controller를 요청하게 해야함
	> 하지만 /* -> /로 변경되면 Controller를 건너뛰고 index.jsp를 직접 요청하는일이 가능해진다.

* 따라서 애초에 View페이지를 직접접근할 수 없게끔 WEB-INF/ 경로에 숨겨놓음 이곳은 사용자가 직접 접근할 수 없는 영역임.
* 다행히도 Controller에선 접근 가능 
	> 클라이언트 접근을 막았지 서버쪽에서 파일을 요청하는것은 허락됨

* 따라서 기존에 viewName을 setting하는 작업의 URL을 변경해준다. mv.setViewName("/WEB-INF/view/index.jsp"); (경로가 길어지지만 해결할 수 있음)
* 이제 View 페이지는 Controller를 통해서만 접근이 가능하다.

* mv.setViewName("/WEB-INF/view/index.jsp");에서 절대경로가 아닌 mv.setViewName("WEB-INF/view/index.jsp"); 상대경로로해도 오류가 나지않음
* 그렇다면 만약 dispatcher-servlet.xml파일의 URL을 /aa/index로 변경하면?
	> http://localhost:8080/webPrj/aa/index 로 요청하면
	> /aa/WEB-INF/view/index.jsp을(를) 찾을 수 없습니다. 라는404 오류 발생, 왜?
	> Controller는 dispatcher-servlet.xml에 의해 http://.../aa/index라는 주소를 가짐
	> 상대경로로 입력하게되면 index라는 주소와 같은 위치에 있다고 판단해 http://.../aa/WEB-INF/view/index.jsp 이렇게 View를 찾게된다.
	> 따라서 이런것을 신경쓰고 싶지 않다면 절대경로를 이용

* 또한 dispatcher-servlet.xml파일에서 url 매핑 이름 정할때는 /를 빼먹으면 안된다. 


* 기존 url을 보면 http://localhost:8080/webPrj/index에서 프로젝트명이 URL에 들어간다.
	> 실제 서비스시 프로젝트명같은 이름은 들어가면 안된다. --> 이는 여러개의 프로젝트를 만들 수 있게 하기 위해 URL에 Context명을 붙여서 그렇다.
	> 따라서 main프로젝트 이므로 Context명을 /(root)로 변경하고 서버에서 싱크된 프로젝트를 지우고 다시 시작한다.

* http://localhost:8080/index로 접속시 index 페이지가 요청이 정상적으로 됨
	> 하지만 controller에서 실행시 index페이지가 나오지 않음(이클립스가 적당한 요청URL로 실제 위치를 요청하므로)
	> 따라서 약간의 편법으로 webapp/index라는 원래 URL구조대로 파일을 만들고 거기서 실행하면 정상적으로 index페이지가 출력된다.
	> 이렇게 되는 이유는 이클립스는 웹 루트에 있는 특정파일을 선택하고 실행하면 그 파일을 브라우저에 써준다.
	> 따라서 이것이 IndexController에 매핑했던 주소와 동일하고 우선순위가 높음
	> 결국 Controller의 URL에 dispatch가 이루어져 기존 페이지가 실행된다.




< ------------------------------------------------------------ ViewResolver 사용하기 ------------------------------------------------------------ >
* 이전에 보안을 위해 View페이지를 WEB-INF/view/로 옮김
	> 이를 통해 경로가 길어지고 페이지를 찾는 과정이 복잡해짐
* 복잡함을 해결하고 쉽게 찾을 수 있게 하는 ViewResolver를 사용해보자

* 뷰 페이지 설정은 setter를 이용했지만 오버로드 생성자를 이용해 객체 생성과 동시에 설정이 가능하다.
	> ModelAndView mv = new ModelAndView("/WEB-INF/view/index.jsp");

* /WEB-INF/view/... .jsp는 반복되며 계속 중복되므로 이것을 빼고 ModelAndView mv = new ModelAndView("index");만 남긴다.
	> 이렇게 반환하면 디스패처가 그런 리소스가 없다(JSP,경로가없음) 이것을 도와주는 것이 ViewResolver의 역할이다.
	> 반환하게 되면 이에 앞뒤에 경로와 파일확장자를 붙여 실질적인 view를 찾게 도와준다.

* dispatchar-servlet.xml 파일에서 뷰 리졸버 빈을 추가한다.
    <!-- ViewResolver 설정 -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <!-- 접두사 -->
        <property name="prefix" value="/WEB-INF/view/"/>
        <!-- 접미사 -->
        <property name="suffix" value=".jsp"/>
    </bean>




< ------------------------------------------------------------ HTML파일 설정하기 ------------------------------------------------------------ >
* 파일 다운로드 및 웹 루트로 옮김
* css미적용 및 이미지 로드 안됨 --> 왜?




























































